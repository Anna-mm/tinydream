<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[枫桥夜泊]]></title>
  <subtitle><![CDATA[梦想走着走着就丢了 只想充实地过每一天 每天都有挑战]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-15T14:55:25.557Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[枫桥]]></name>
    <email><![CDATA[ajiao5198@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[前端MVC变形记]]></title>
    <link href="http://yoursite.com/2015/10/22/mvc-deformation/"/>
    <id>http://yoursite.com/2015/10/22/mvc-deformation/</id>
    <published>2015-10-22T00:00:00.000Z</published>
    <updated>2015-12-15T14:55:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="背景：">背景：</h2>
<p>MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。在过去，MVC被大量用于构建桌面和服务器端应用程序，如今Web应用程序的开发已经越来越向传统应用软件开发靠拢，Web和应用之间的界限也进一步模糊。传统编程语言中的设计模式也在慢慢地融入Web前端开发。由于前端开发的环境特性，在经典MVC模式上也引申出了诸多MV*模式，被实现到各个Javascript框架中都有多少的衍变。在研究MV*模式和各框架的过程中，却是“剪不断、理还乱”：</p>
<ol>
<li>为什么每个地方讲的MVC都不太一样？</li>
<li>MVP、MVVM的出现是要解决什么问题？</li>
<li>为什么有人义正言辞的说“MVC在Web前端开发中根本无法使用”？</li>
</ol>
<p>带着十万个为什么去翻阅很多资料，但是看起来像view、model、controller、解耦、监听、通知、主动、被动、注册、绑定、渲染等各种术语的排列组合，像汪峰的歌词似的。本篇希望用通俗易懂的方式阐述清楚一些关系，由于接触时间有限，英文阅读能力有限，可能会存在误解，欢迎讨论和纠正。</p>
<a id="more"></a>

<h2 id="MVC变形记">MVC变形记</h2>
<h3 id="MVC历史">MVC历史</h3>
<p>MVC最初是在研究Smalltalk-80（1979年）期间设计出来的，恐怕没有一本书能够回到计算机石器时代介绍一下Smalltalk的代码是如何实现MVC的，不仅如此，连想搞清楚当时的应用场景都很难了，都要追溯到80后出生以前的事了。但是当时的图形界面少之又少，施乐公司正在研发友好的用户图形界面，以取代电脑屏幕上那些拒人于千里之外的命令行和DOS提示符。那时计算机世界天地混沌，浑然一体，然后出现了一个创世者，将现实世界抽象出模型形成model，将人机交互从应用逻辑中分离形成view，然后就有了空气、水、鸡啊、蛋什么的。在1995年出版的《设计模式：可复用面向对象软件的基础》对MVC进行了深入的阐述，在推广使用方面发挥了重要作用。</p>
<p>MVC包括三类对象，将他们分离以提高灵活性和复用性。</p>
<ul>
<li><p>模型model用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。</p>
</li>
<li><p>视图view是它在屏幕上的表示，描绘的是model的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。</p>
</li>
<li><p>控制器controller定义用户界面对用户输入的响应方式，起到不同层面间的组织作用，用于控制应用程序的流程，它处理用户的行为和数据model上的改变。</p>
</li>
</ul>
<p><img src="/blog/mvc-deformation/img/typicalMVC.png" alt="经典MVC模式"></p>
<p>实线：方法调用<br>虚线：事件通知</p>
<p>其中涉及两种设计模式：</p>
<ul>
<li><p>view和model之间的观察者模式，view观察model，事先在此model上注册，以便view可以了解在数据model上发生的改变。</p>
</li>
<li><p>view和controller之间的策略模式</p>
</li>
</ul>
<blockquote>
<p>一个策略是一个表述算法的对象，MVC允许在不改变视图外观的情况下改变视图对用户输入的响应方式。例如，你可能希望改变视图对键盘的响应方式，或希望使用弹出菜单而不是原来的命令键方式。MVC将响应机制封装在controller对象中。存在着一个controller的类层次结构，使得可以方便地对原有的controller做适当改变而创建新的controller。</p>
<p>view使用controller子类的实例来实现一个特定的响应策略。要实现不同的响应的策略只要用不同种类的controller实例替换即可。甚至可以在运行时刻通过改变view的controller来改变用户输入的响应方式。例如，一个view可以被禁止接受任何输入，只需给他一个忽略输入事件的controller。</p>
</blockquote>
<p>好吧，如果被上述言论绕昏了，请继续研读《设计模式：可复用面向对象软件的基础》。</p>
<h3 id="MVC_for_JAVASCRIPT">MVC for JAVASCRIPT</h3>
<p>我们回顾了经典的MVC，接下来讲到的MVC主要是在Javascript上的实现。</p>
<p><img src="/blog/mvc-deformation/img/javascriptMVC.png" alt="javascript MVC模式"></p>
<p><a href="https://www.safaribooksonline.com/library/view/learning-javascript-design/9781449334840/ch10s02.html" target="_blank" rel="external">源图</a></p>
<p>如图所示，view承接了部分controller的功能，负责处理用户输入，但是不必了解下一步做什么。它依赖于一个controller为她做决定或处理用户事件。事实上，前端的view已经具备了独立处理用户事件的能力，如果每个事件都要流经controller，势必增加复杂性。同时，view也可以委托controller处理model的更改。model数据变化后通知view进行更新，显示给用户。这个过程是一个圆，一个循环的过程。</p>
<p>这种从经典MVC到Javascript MVC的1对1转化，导致控制器的角色有点尴尬。MVC这样的结构的正确性在于，任何界面都需要面对一个用户，而controller “是用户和系统之间的链接”。在经典MVC中，controller要做的事情多数是派发用户输入给不同的view，并且在必要的时候从view中获取用户输入来更改model，而Web以及绝大多数现在的UI系统中，controller的职责已经被系统实现了。由于某种原因，控制器和视图的分界线越来越模糊，也有认为，view启动了action理论上应该把view归属于controller。比如在Backbone中，Backbone.View和Backbone.Router一起承担了controller的责任。这就为MVC中controller的衍变埋下了伏笔。</p>
<h3 id="MVP">MVP</h3>
<p>MVP（model-view-Presenter）是经典MVC设计模式的一种衍生模式，是在1990年代Taligent公司创造的，一个用于C++ CommonPoint的模型。背景上不再考证，直接上图看一下与MVC的不同。</p>
<p><img src="/blog/mvc-deformation/img/mvp.png" alt="MVP模式"></p>
<p>经典MVC中，一对controller-view捆绑起来表示一个ui组件，controller直接接受用户输入，并将输入转为相应命令来调用model的接口，对model的状态进行修改，最后通过观察者模式对view进行重新渲染。</p>
<p>进化为MVP的切入点是修改controller-view的捆绑关系，为了解决controller-view的捆绑关系，将进行改造，使view不仅拥有UI组件的结构，还拥有处理用户事件的能力，这样就能将controller独立出来。为了对用户事件进行统一管理，view只负责将用户产生的事件传递给controller，由controller来统一处理，这样的好处是多个view可共用同一个controller。此时的controller也由组件级别上升到了应用级别，然而更新view的方式仍然与经典MVC一样：通过Presenter更新model，通过观察者模式更新view。</p>
<p>另一个显而易见的不同在于，MVC是一个圆，一个循环的过程，但MVP不是，依赖Presenter作为核心，负责从model中拿数据，填充到view中。常见的MVP的实现是被动视图(passive view),Presenter观察model，不再是view观察model，一旦model发生变化，就会更新view。Presenter有效地绑定了model到view。view暴露了setters接口以便Presenter可以设置数据。对于这种被动视图的结构，没有直接数据绑定的概念。但是他的好处是在view和model直接提供更清晰的分离。但是由于缺乏数据绑定支持，意味着不得不单独关注某个任务。在MVP里，应用程序的逻辑主要在Presenter来实现，其中的view是很薄的一层。</p>
<h3 id="MVVM">MVVM</h3>
<p>MVVM，Model-View-ViewModel，最初是由微软在使用Windows Presentation Foundation和SilverLight时定义的，2005年John Grossman在一篇关于Avalon（WPF 的代号）的博客文章中正式宣布了它的存在。如果你用过Visual Studio, 新建一个WPF Application，然后在“设计”中拖进去一个控件、双击后在“代码”中写事件处理函数、或者绑定数据源。就对这个MVVM有点感觉了。比如VS自动生成的如下代码：</p>
<figure class="highlight xaml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">GroupBox</span> <span class="attribute">Header</span>=<span class="value">"绑定对象"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">StackPanel</span> <span class="attribute">Orientation</span>=<span class="value">"Horizontal"</span> <span class="attribute">Name</span>=<span class="value">"stackPanel1"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"学号:"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"{Binding Path=StudentID}"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"姓名:"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"{Binding Path=Name}"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"入学日期:"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"{Binding Path=EntryDate, StringFormat=yyyy-MM-dd}"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"学分:"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">TextBlock</span> <span class="attribute">Text</span>=<span class="value">"{Binding Path=Credit}"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">StackPanel</span>&gt;</span>
<span class="tag">&lt;/<span class="title">GroupBox</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>stackPanel1.DataContext = <span class="keyword">new</span> Student() {
    StudentID=<span class="number">20130501</span>,
    Name=<span class="string">"张三"</span>,
    EntryDate=DateTime.Parse(<span class="string">"2013-09-01"</span>),
    Credit=<span class="number">0.0</span>
};
</pre></td></tr></table></figure>

<p>其中最重要的特性之一就是数据绑定，Data-binding。没有前后端分离，一个开发人员全搞定，一只手抓业务逻辑、一只手抓数据访问，顺带手拖放几个UI控件，绑定数据源到某个对象或某张表，一步到位。</p>
<p>背景介绍完毕，再来看一下理论图</p>
<p><img src="/blog/mvc-deformation/img/mvvm.png" alt="MVVM模式"></p>
<p>首先，view和model是不知道彼此存在的，同MVP一样，将view和model清晰地分离开来。<br>其次，view是对viewmodel的外在显示，与viewmodel保持同步，viewmodel对象可以看作是view的上下文。view绑定到viewmodel的属性上，如果viewmodel中的属性值变化了，这些新值通过数据绑定会自动传递给view。反过来viewmodel会暴露model中的数据和特定状态给view。<br>所以，view不知道model的存在，viewmodel和model也觉察不到view。事实上，model也完全忽略viewmodel和view的存在。这是一个非常松散耦合的设计。</p>
<h2 id="流行的MV*框架：">流行的MV*框架：</h2>
<p>每个框架都有自己的特性，这里主要讨论MVC三个角色的责任。粗浅地过一遍每个框架的代码结构和风格。</p>
<h3 id="BackboneJS">BackboneJS</h3>
<p>Backbone通过提供模型Model、集合Collection、视图View赋予了Web应用程序分层结构，其中模型包含领域数据和自定义事件；集合Colection是模型的有序或无序集合，带有丰富的可枚举API； 视图可以声明事件处理函数。最终将模型、集合、视图与服务端的RESTful JSON接口连接。</p>
<p>Backbone在升级的过程中，去掉了controller，由view和router代替controller，view集中处理了用户事件（如click，keypress等）、渲染HTML模板、与模型数据的交互。Backbone的model没有与UI视图数据绑定，而是需要在view中自行操作DOM来更新或读取UI数据。Router为客户端路由提供了许多方法，并能连接到指定的动作（actions）和事件（events）。</p>
<p>Backbone是一个小巧灵活的库，只是帮你实现一个MVC模式的框架，更多的还需要自己去实现。适合有一定Web基础，喜欢原生JS去操作DOM（因为没有数据绑定）的开发人员。为什么称它为库，而不是框架，不仅仅是由于仅4KB的代码，更重要的是<br>使用一个库，你有控制权。如果用一个框架，控制权就反转了，变成框架在控制你。库能够给予灵活和自由，但是框架强制使用某种方式，减少重复代码。这便是Backbone与Angular的区别之一了。</p>
<p>至于Backbone属于MV*中的哪种模式，有人认为不是MVC，有人觉得更接近于MVP，事实上，它借用多个架构模式中一些很好的概念，创建一个运行良好的灵活框架。不必拘泥于某种模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre><span class="comment">// view:</span>
<span class="keyword">var</span> Appview = Backbone.View.extend({
    <span class="comment">// 每个view都需要一个指向DOM元素的引用，就像ER中的main属性。</span>
    el: <span class="string">'#container'</span>,

    <span class="comment">// view中不包含html标记，有一个链接到模板的引用。</span>
    template: _.template(<span class="string">"&lt;h3&gt;Hello &lt;%= who %&gt;&lt;/h3&gt;"</span>),

    <span class="comment">// 初始化方法</span>
    initialize: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">this</span>.render();
    },

    <span class="comment">// $el是一个已经缓存的jQuery对象</span>
    render: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">this</span>.$el.html(<span class="string">"Hello World"</span>);
    },

    <span class="comment">// 事件绑定</span>
    events: {<span class="string">'keypress #new-todo'</span>: <span class="string">'createTodoOnEnter'</span>}
});
<span class="keyword">var</span> appview = <span class="keyword">new</span> Appview();

<span class="comment">// model:</span>
<span class="comment">// 每个应用程序的核心、包含了交互数据和逻辑</span>
<span class="comment">// 如数据验证、getter、setter、默认值、数据初始化、数据转换</span>
<span class="keyword">var</span> app = {};

app.Todo = Backbone.model.extend({
  defaults: {
    title: <span class="string">''</span>,
    completed: <span class="literal">false</span>
  }
});

<span class="comment">// 创建一个model实例</span>
<span class="keyword">var</span> todo = <span class="keyword">new</span> app.Todo({title: <span class="string">'Learn Backbone.js'</span>, completed: <span class="literal">false</span>});
todo.get(<span class="string">'title'</span>); <span class="comment">// "Learn Backbone.js"</span>
todo.get(<span class="string">'completed'</span>); <span class="comment">// false</span>
todo.get(<span class="string">'created_at'</span>); <span class="comment">// undefined</span>
todo.set(<span class="string">'created_at'</span>, <span class="built_in">Date</span>());
todo.get(<span class="string">'created_at'</span>); <span class="comment">// "Wed Sep 12 2012 12:51:17 GMT-0400 (EDT)"</span>

<span class="comment">// collection：</span>
<span class="comment">// model的有序集合，可以设置或获取model</span>
<span class="comment">// 监听集合中的数据变化，从后端获取模型数据、持久化。</span>
app.TodoList = Backbone.Collection.extend({
  model: app.Todo,
  localStorage: <span class="keyword">new</span> Store(<span class="string">"backbone-todo"</span>)
});

<span class="comment">// collection实例</span>
<span class="keyword">var</span> todoList = <span class="keyword">new</span> app.TodoList()
todoList.create({title: <span class="string">'Learn Backbone\'s Collection'</span>});

<span class="comment">// model实例</span>
<span class="keyword">var</span> model = <span class="keyword">new</span> app.Todo({title: <span class="string">'Learn models'</span>, completed: <span class="literal">true</span>});
todoList.add(model);
todoList.pluck(<span class="string">'title'</span>);
todoList.pluck(<span class="string">'completed'</span>);
</pre></td></tr></table></figure>

<h3 id="KnockoutJS">KnockoutJS</h3>
<p>KnockoutJS是一个名正言顺的MVVM框架，通过简洁易读的data-bind语法，将DOM元素与viewmodel关联起来。当模型（viewmodel）状态更新时，自动更新UI界面。<br>viewmodel是model和view上的操作的一个连接，是一个纯粹的Javascript对象。它不是UI，没有控件和样式的概念，它也不是持久化的模型数据，它只是hold住一些用户正在编辑的数据，然后暴露出操作这些数据（增加或删除）的方法。</p>
<p>view是对viewmodel中数据的一个可视化的显示，view观察viewmodel，操作view时会发送命令到viewmodel，并且当viewmodel变化时更新。view和model是不了解彼此的存在的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">form</span> <span class="attribute">data-bind</span>=<span class="value">"submit: addItem"</span>&gt;</span>
    New item:
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">data-bind</span>=<span class="value">'value: itemToAdd, valueUpdate: "afterkeydown"'</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">data-bind</span>=<span class="value">"enable: itemToAdd().length &gt; 0"</span>&gt;</span>Add<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Your items:<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">select</span> <span class="attribute">multiple</span>=<span class="value">"multiple"</span> <span class="attribute">width</span>=<span class="value">"50"</span> <span class="attribute">data-bind</span>=<span class="value">"options: items"</span>&gt;</span> <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// viewmodel</span>
<span class="keyword">var</span> SimpleListmodel = <span class="function"><span class="keyword">function</span><span class="params">(items)</span> {</span>
    <span class="keyword">this</span>.items = ko.observableArray(items);
    <span class="keyword">this</span>.itemToAdd = ko.observable(<span class="string">""</span>);
    <span class="keyword">this</span>.addItem = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.itemToAdd() != <span class="string">""</span>) {
            <span class="comment">// 把input中的值加入到items，会自动更新select控件</span>
            <span class="keyword">this</span>.items.push(<span class="keyword">this</span>.itemToAdd());
            <span class="comment">// 清空input中的值</span>
            <span class="keyword">this</span>.itemToAdd(<span class="string">""</span>);
        }
    <span class="comment">// 确保这里的this一直是viewmodel</span>
    }.bind(<span class="keyword">this</span>);
};

ko.applyBindings(<span class="keyword">new</span> SimpleListmodel([<span class="string">"Alpha"</span>, <span class="string">"Beta"</span>, <span class="string">"Gamma"</span>]));
</pre></td></tr></table></figure>

<h3 id="AngularJS">AngularJS</h3>
<p>AngularJS试图成为Web应用中的一种端对端的解决方案。这意味着它不只是你的Web应用中的一个小部分，而是一个完整的端对端的解决方案。这会让AngularJS在构建一个CRUD的应用时看起来很呆板，缺乏灵活性。AngularJS是为了克服HTML在构建应用上的不足而设计的。使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。通过使用标识符(directives)的结构，让浏览器能够识别新的语法。例如使用双大括号{{}}语法进行数据绑定；使用ng-controller指定每个控制器负责监视视图中的哪一部分；使用ng-model，把输入数据绑定到模型中的一部分属性上。</p>
<p>双向数据绑定是AngularJS的另一个特性。UI控件的任何更改会立即反映到模型变量（一个方向），模型变量的任何更改都会立即反映到问候语文本中（另一方向）。AngularJS通过作用域来保持数据模型与视图界面UI的双向同步。一旦模型状态发生改变，AngularJS会立即刷新反映在视图界面中，反之亦然。</p>
<p>AngularJS原本是倾向于MVC，但是随着项目重构和版本升级，现在更接近MVVM。和Knockout view中的风格类似，都像从WPF衍变过来的，只是Knockout使用了自定义属性data-bind作为绑定入口，而AngularJS对于HTML的变革更彻底，扩展HTML的语法，引入一系列的指令。</p>
<p>在AngularJS中，一个视图是模型通过HTML模板渲染之后的映射。这意味着，不论模型什么时候发生变化，AngularJS会实时更新结合点，随之更新视图。比如，视图组件被AngularJS用下面这个模板构建出来：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-controller</span>=<span class="value">"PhoneListCtrl"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
        <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"phone in phones"</span>&gt;</span>
            
            <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<p>在li标签里面的ng-repeat语句是一个AngularJS迭代器。包裹在phone.name和phone.snippet周围的花括号标识着数据绑定，是对应用一个数据模型的引用。当页面加载的时候，AngularJS会根据模版中的属性值，将其与数据模型中相同名字的变量绑定在一起，以确保两者的同步性。</p>
<p>在PhoneListCtrl控制器里面初始化了数据模型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">// controller:</span>
<span class="function"><span class="keyword">function</span> <span class="title">PhoneListCtrl</span><span class="params">($scope)</span> {</span>
  <span class="comment">// 数组中存储的对象是手机数据列表</span>
  $scope.phones = [
    {<span class="string">"name"</span>: <span class="string">"Nexus S"</span>,
     <span class="string">"snippet"</span>: <span class="string">"Fast just got faster with Nexus S."</span>},
    {<span class="string">"name"</span>: <span class="string">"Motorola XOOM™ with Wi-Fi"</span>,
     <span class="string">"snippet"</span>: <span class="string">"The Next, Next Generation tablet."</span>},
    {<span class="string">"name"</span>: <span class="string">"MOTOROLA XOOM™"</span>,
     <span class="string">"snippet"</span>: <span class="string">"The Next, Next Generation tablet."</span>}
  ];
}
</pre></td></tr></table></figure>

<p>尽管控制器看起来并没有什么控制的作用，但是它在这里的重要性在于，通过给定数据模型的作用域$scope，允许建立模型和视图之间的数据绑定。方法名PhoneListCtrl和body标签里面的ngcontroller指令的值相匹配。当应用启动之后，会有一个根作用域被创建出来，而控制器的作用域是根作用域的一个典型后继。这个控制器的作用域对所有<body ng-controller="PhoneListCtrl" \="">标记内部的数据绑定有效。</body></p>
<p>AngularJS的作用域理论非常重要：一个作用域可以视作模板、模型和控制器协同工作的粘接器。AngularJS使用作用域，同时还有模板中的信息，数据模型和控制器。这些可以帮助模型和视图分离，但是他们两者确实是同步的！任何对于模型的更改都会即时反映在视图上；任何在视图上的更改都会被立刻体现在模型中。</p>
<h2 id="实践中的思考">实践中的思考</h2>
<p>我们使用的MVC框架是<a href="https://github.com/ecomfe/er" target="_blank" rel="external">ER</a>，适用于并能很方便地构建一个整站式的AJAX Web应用。提供精简、核心的action、model和view的抽象，使得构建RIA应用变得简单可行。在使用的过程中近距离地体会到非常多方面的优秀的设计理念。也让我开始思考各个角色的转型。</p>
<h3 id="让view上前线">让view上前线</h3>
<p>我开始思考action（controller）这个角色。我觉得从纯粹地解耦角度来说，view和model应该是互相不知道彼此存在的，所有的事件流和对数据、UI的处理应该都流经action。但是这一点又极不现实。用户操作了一个UI，需要更新model的一个数据，就要fire到action，通过action来调用model的set方法。这样又有点麻烦，因为view中有对model的应用，可以一句代码搞定这一个数据的设置。所以，我自己设置了一个规则：如果是简单的模型数据读写可以直接在view中操作；如果要经过复杂的数据处理，必须流经action。于是，我遇到了一种怎么都偷不了懒（必须经过action）的情况：<br>比如有个主action main，两个子action list、select，用户在list中的view选择一条数据添加到右侧select中。那走过的流程是这样的：</p>
<p><img src="/blog/mvc-deformation/img/practice.png" alt="实践中的思考"></p>
<ol>
<li>子Action中的listView接受UI事件，fire到listAction中</li>
<li>listAction继续将事件fire到mainView中，由主action来处理另外子Action的事情。</li>
<li>mainView接收到事件、调用子Action selectAction的方法</li>
<li>selectAction继续调用selectView的方法来完成UI的更新。</li>
</ol>
<p>其中涉及的model的变化暂时不考虑。我在想，view既然把经典MVC中的controller接受用户事件的角色承接过来的，那如果借鉴Backbone的思想，把view作为controller的一个实现，推到战场的最前线。省掉两次action的中转传递，是不是更简单。</p>
<h3 id="model驱动开发">model驱动开发</h3>
<p>实际开发中，常常会以view为核心，页面上需要展示什么数据，就去model中设置数据源。发生了用户事件，我会在action中更新model，然后刷新view。有时候会遗漏更新model，直到需要数据时才发现没有保存到model中。</p>
<p>model本身是独立的，自控制的，不依赖于view，能够同步支持多view的显示。就像linux上的应用程序通常会提供图形界面和命令行两种操作方式一样。那如果以model为核心，model驱动开发，数据在手、天下我有，以模型验证保证数据的完整性和正确性。实现数据绑定，任何对模型的更改都会在界面上反映出来。那我们只要预先写好view和model的关系映射（类似viewmodel），然后只关注模型数据，就OK了。</p>
<p><strong>对于MV*家族，都是在经典MVC基础上随着时代的发展、应用环境的变化衍变出来的。实现MV*模式的这些框架到底归属于哪种模式，也不必泥古。MV*是一个很有争议性的话题，能够构建一个健壮、具有良好设计、遵从关注点分离的项目比花时间去争论到底是MV*更有意义。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景：">背景：</h2>
<p>MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。在过去，MVC被大量用于构建桌面和服务器端应用程序，如今Web应用程序的开发已经越来越向传统应用软件开发靠拢，Web和应用之间的界限也进一步模糊。传统编程语言中的设计模式也在慢慢地融入Web前端开发。由于前端开发的环境特性，在经典MVC模式上也引申出了诸多MV*模式，被实现到各个Javascript框架中都有多少的衍变。在研究MV*模式和各框架的过程中，却是“剪不断、理还乱”：</p>
<ol>
<li>为什么每个地方讲的MVC都不太一样？</li>
<li>MVP、MVVM的出现是要解决什么问题？</li>
<li>为什么有人义正言辞的说“MVC在Web前端开发中根本无法使用”？</li>
</ol>
<p>带着十万个为什么去翻阅很多资料，但是看起来像view、model、controller、解耦、监听、通知、主动、被动、注册、绑定、渲染等各种术语的排列组合，像汪峰的歌词似的。本篇希望用通俗易懂的方式阐述清楚一些关系，由于接触时间有限，英文阅读能力有限，可能会存在误解，欢迎讨论和纠正。</p>
]]>
    
    </summary>
    
      <category term="JAVASCRIPT" scheme="http://yoursite.com/tags/JAVASCRIPT/"/>
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
      <category term="MVP" scheme="http://yoursite.com/tags/MVP/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有效地勤奋]]></title>
    <link href="http://yoursite.com/2015/05/12/per-memory/"/>
    <id>http://yoursite.com/2015/05/12/per-memory/</id>
    <published>2015-05-12T06:02:26.000Z</published>
    <updated>2015-05-12T08:21:05.000Z</updated>
    <content type="html"><![CDATA[<p>像博客签名一样”梦想走着走着就丢了，只想充实地过每一天，每天都有挑战“，我一直践行着，脚踏实地。不喜欢计算利益得失寻求技巧的“聪明”孩子或者伪装得很“聪明”的孩子，有些人确实比较聪明，要么是天生的、父辈的勤奋习得传承下来的聪明基因、要么是后天的努力。我爷爷是小学毕业、村里的会计；我爸爸是高中毕业、高考落榜；所以我先天的聪明是有限的，或者说出生于这样的平台之上我已心怀感激，于是剩下的就靠自己了。我一直以勤奋自诩，直到近来发生的一些小事我开始思考如何更有效。</p>
<h3 id="专业书都看过了，我也不是专家">专业书都看过了，我也不是专家</h3>
<p>我非常喜欢看书，直到前段时间才正式放弃去国图借书切换到电子阅读平台。偶然间我发现了这样一张图，<br><img src="/img/memory1.png" alt="两周后你还记得什么"><br>kao，两周后读过的书只剩下10%，难道这是最低效的学习方式？难怪有些书看完之后隔很久再看感觉跟没看过一样。难怪我还不是领域专家。是的，我们都知道遗忘曲线，上学的时候背单词、复习，都是学而时习之，可是工作之后看书谁还会在看完的1、2、4、7、15天再复习一遍。何况在信息充斥的现在，百度一下就知道了，关闭网页就忘记了。而且注意力越发涣、思考越来越浅。还记得以前老师常讲的读书要眼到、口到、笔到、心到，那多累啊。</p>
<h3 id="做了一个月仰卧起坐，我也没有马甲线">做了一个月仰卧起坐，我也没有马甲线</h3>
<p>我有一个月的时间里，每天200～300个仰卧起坐，体重没有下降、小腹也没有平旦、更不要提马甲线。这对我打击非常大。直到跟一个健身达人聊天才发觉，可能是自己的方法不对。我就像上学时仰卧起坐考试那样、屈腿、仰卧、坐起。达人说不需要完全的坐起、上身起到某一个点上腹部会非常紧绷、吃力，再循环做就好了。我心想，那多累啊。</p>
<p>这两件事，让我开始认真地思考“有效”以及我的座右铭，它像在默默地诉说：你的时间很充足，只管做就好了，总会慢慢地变得熟练、扎实。可现在，我感觉到时间不再充足、想要快一点，有效一点。我们再回顾一下上张图，会发现“我们说过的事”在两周之后也会记得大概80%，可见“说”是非常重要。是时候摒弃“默默地工作”这个信条了，它不仅让你慢慢地忘记做过的事情，也让别人不易觉察到你的付出。“说吧，不要钱。”</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>像博客签名一样”梦想走着走着就丢了，只想充实地过每一天，每天都有挑战“，我一直践行着，脚踏实地。不喜欢计算利益得失寻求技巧的“聪明”孩子或者伪装得很“聪明”的孩子，有些人确实比较聪明，要么是天生的、父辈的勤奋习得传承下来的聪明基因、要么是后天的努力。我爷爷是小学毕业、村里的]]>
    </summary>
    
      <category term="高效率 有效 工作 方法" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%88%E7%8E%87-%E6%9C%89%E6%95%88-%E5%B7%A5%E4%BD%9C-%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery事件系统三]]></title>
    <link href="http://yoursite.com/2014/10/13/js-event3/"/>
    <id>http://yoursite.com/2014/10/13/js-event3/</id>
    <published>2014-10-13T07:34:49.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>上一节通过给DOM元素添加自定义数据引出jQuery.data这个数据缓存模块，这是数据缓存系统的另一大重头戏，这一节就好好说说jQuery.data。再看jquery源码之前大概大概明确几个要点：</p>
<p>1、jQuery.expando = “jQuery” + ( jQuery.fn.jquery + Math.random() )，即jQuery＋版本号＋随机数；</p>
<p>2、jQuery.data方法通过参数的不同，可以有几种用法：为DOM元素或Javascript对象设置任意类型的数据，或返回指定名称的数据，或返回关联的数据缓存对象。</p>
<p>3、数据缓存对象上区分内部数据和自定义数据，避免jQuery内部使用的数据和用户自定义的数据发生冲突。<br>方法._data()设置的数据为内部数据，直接存储在关联的数据存储对象上，如事件缓存数据。<br>方法.data()设置的数据为自定义数据，存储在关联的数据缓存对象的属性data上；如用户通过data-*自定义数据。</p>
<p> 在上节栗子中设置content元素的自定义属性如下，存储位置如下：</p>
<pre><code> <span class="variable">$(</span><span class="string">".content"</span>).data({<span class="string">"tagName"</span><span class="symbol">:<span class="string">"div"</span></span>,<span class="string">"className"</span><span class="symbol">:<span class="string">"content"</span></span>});
</code></pre><p> <img src="/img/jsevent3.png" alt="数据缓存系统"></p>
<p> 总结一下：上节中通过jQuery._data设置DOM元素的内部属性，事实上是通过jQuery.data实现的，只是传递pvt参数为true（用于内部属性或自定义属性的标识），在jQuery.cache上顺序挂上key值为1、2、3…依此类推的数据缓存对象。同时设置DOM元素本身的属性elem[ jQuery.expando ] = id；以此来关联数据缓存系统。</p>
<p> <img src="/img/jsevent4.png" alt="数据缓存系统"></p>
<p>源码如下：</p>
<pre><code>jQuery.extend({
    cache: {},<span class="comment">//事件缓存系统</span>
    deletedIds: [],
    uuid: <span class="number">0</span>,<span class="comment">// uuid初始化</span>
    <span class="comment">// 生成类似于jQuery18005268001211807132这样的随机数（），避免与用户的自定义属性名冲突</span>
    expando: <span class="string">"jQuery"</span> + ( jQuery.fn.jquery + <span class="built_in">Math</span>.random() ).replace( <span class="regexp">/\D/g</span>, <span class="string">""</span> ),
    <span class="comment">//jQuery.noData中存放了不支持扩展属性的embed、object、applet元素的节点名称。</span>
    noData: {
        <span class="string">"embed"</span>: <span class="literal">true</span>,
        <span class="string">"object"</span>: <span class="string">"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</span>,<span class="comment">//用于检查object元素是否是flash</span>
        <span class="string">"applet"</span>: <span class="literal">true</span>
    },

    <span class="comment">//判断一个DOM元素或javascript对象是否有关联的数据</span>
    hasData: <span class="function"><span class="keyword">function</span><span class="params">( elem )</span> {</span>
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
        <span class="keyword">return</span> !!elem &amp;&amp; !isEmptyDataObject( elem );
    },

    <span class="comment">//为DOM元素或javascript对象设置任何类型的数据</span>
    data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data, pvt <span class="comment">/* Internal Use Only */</span> )</span> {</span>
        <span class="comment">//是否可以附加数据，不可以的话直接返回</span>
        <span class="keyword">if</span> ( !jQuery.acceptData( elem ) ) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> thisCache, ret,
            <span class="comment">//jQuery.expando是一个唯一的字符串，jquery对象产生的时候就生成</span>
            internalKey = jQuery.expando,
            getByName = <span class="keyword">typeof</span> name === <span class="string">"string"</span>,
            <span class="comment">// 区分DOM对象和javascript对象，如果是DOM元素，为了避免javascript和DOM元素之间循环引用导致的浏览器（IE6、7）垃圾回收机制不起作用，要把数据存储在全局缓存对象jQuery.cache中；对于Javascript对象，垃圾回收机制自动发生，数据可以之间存储在javascript对象上。</span>
            isNode = elem.nodeType,
            ......
        <span class="comment">//如果关联id不存在，则分配一个。</span>
        <span class="keyword">if</span> ( !id ) {
            <span class="keyword">if</span> ( isNode ) {
                elem[ internalKey ] = id = jQuery.deletedIds.pop() || ++jQuery.uuid;
            } <span class="keyword">else</span> {
                id = internalKey;
            }
        }
        <span class="comment">//如果数据缓存对象不存在，就初始化为空对象</span>
        <span class="keyword">if</span> ( !cache[ id ] ) {
            cache[ id ] = {};
            ......
        }
        <span class="comment">// 如果参数name是对象或函数，则批量设置数据</span>
        <span class="keyword">if</span> ( <span class="keyword">typeof</span> name === <span class="string">"object"</span> || <span class="keyword">typeof</span> name === <span class="string">"function"</span> ) {
            <span class="keyword">if</span> ( pvt ) {
                cache[ id ] = jQuery.extend( cache[ id ], name );
            } <span class="keyword">else</span> {
                cache[ id ].data = jQuery.extend( cache[ id ].data, name );
            }
        }
        thisCache = cache[ id ];
        <span class="comment">// 如果参数pvt为true，则设置或读取内部数据，内部数据存储在关联的数据存储对象上；</span>
        <span class="comment">// 如果参数pvt为false，则设置或读取自定义数据，自定义数据存储在关联的数据缓存对象的属性data上。</span>
        <span class="keyword">if</span> ( !pvt ) {
            <span class="keyword">if</span> ( !thisCache.data ) {
                thisCache.data = {};
            }
            thisCache = thisCache.data;
        }
        <span class="comment">//如果参数data不是undefined，则把参数data设置到属性name上。把name统一换成驼峰式。</span>
        <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
            thisCache[ jQuery.camelCase( name ) ] = data;
        }
        <span class="comment">// 参数name为字符串，data为null时读取单个数据。两次读取，使用name读取一次，使用驼峰式再读取一次。</span>
        <span class="keyword">if</span> ( getByName ) {
            ret = thisCache[ name ];
            <span class="keyword">if</span> ( ret == <span class="literal">null</span> ) {
                ret = thisCache[ jQuery.camelCase( name ) ];
            }
        } <span class="keyword">else</span> {
            <span class="comment">//未传入参数name、data、则返回数据缓存对象。</span>
            ret = thisCache;
        }
        <span class="keyword">return</span> ret;
    },
    <span class="comment">//用于移除通过jQuery.data()设置的数据</span>
    removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, pvt <span class="comment">/* Internal Use Only */</span> )</span> {</span>
        ......
    },
    <span class="comment">// 设置或读取内部数据时使用</span>
    _data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> {</span>
        <span class="keyword">return</span> jQuery.data( elem, name, data, <span class="literal">true</span> );
    },
    <span class="comment">// 判断DOM元素是否可以设置数据，通过检查DOM元素的节点名称在对象jQuery.noData中是否存在</span>
    acceptData: <span class="function"><span class="keyword">function</span><span class="params">( elem )</span> {</span>
        <span class="keyword">var</span> noData = elem.nodeName &amp;&amp; jQuery.noData[ elem.nodeName.toLowerCase() ];
        <span class="keyword">return</span> !noData || noData !== <span class="literal">true</span> &amp;&amp; elem.getAttribute(<span class="string">"classid"</span>) === noData;
    }
});
</code></pre><p>本节内容参考《jQuery技术内幕》第五章数据缓存Data</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一节通过给DOM元素添加自定义数据引出jQuery.data这个数据缓存模块，这是数据缓存系统的另一大重头戏，这一节就好好说说jQuery.data。再看jquery源码之前大概大概明确几个要点：</p>
<p>1、jQuery.expando = “jQuery” + ]]>
    </summary>
    
      <category term="jQuery event 事件 数据缓存 W3C 浏览器" scheme="http://yoursite.com/tags/jQuery-event-%E4%BA%8B%E4%BB%B6-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98-W3C-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery事件系统二]]></title>
    <link href="http://yoursite.com/2014/10/11/js-event2/"/>
    <id>http://yoursite.com/2014/10/11/js-event2/</id>
    <published>2014-10-11T10:01:11.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>jQuery事件系统并没有将事件监听函数直接绑定到DOM元素上，而是基于数据缓存系统管理监听函数的。举一个简单的栗子看一下何为数据缓存系统：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">name</span>=<span class="value">"submit"</span> <span class="attribute">value</span>=<span class="value">"click me"</span> <span class="attribute">class</span>=<span class="value">"btn"</span> /&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    $(<span class="string">".box"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"box"</span>);
    })
    $(<span class="string">".content"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"content click 1"</span>);
    })
    $(<span class="string">".content"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"content click 2"</span>);
    }) 
    $(<span class="string">".content"</span>).hover(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"hover in"</span>);
    },<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"hover out"</span>);
    }) 
    $(<span class="string">".btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"btn"</span>);
    }) 
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>如上述代码所示，页面上有一对父子元素box、content和一个按钮btn。</p>
<ul>
<li>父元素box绑定了click事件</li>
<li>子元素content绑定了两个click事件，一个hover事件</li>
<li>btn元素绑定了一个click事件。</li>
</ul>
<p>我们看一下chrome下面打印jQuery.cache是什么情况：<br><img src="/img/jsevent1.png" alt="jQuery事件系统"></p>
<p>由上图所示，</p>
<ul>
<li>jQuery.cache中存储了三个以ID为key值的对象，三个ID是为页面中的box、content、btn元素分配的唯一ID。</li>
<li>每个object中存储了events和handle两个对象。</li>
<li>events对象存储了click、mouseout、mouseover三个事件对象，click对象的值是一个存储了两个元素的数组，对应content元素的两个click事件和hover事件。</li>
<li>click[0]的数组元素中存储了一个guid，唯一标识事件处理函数的ID，以此类推jQuery.cache[1].events.click[0].guid == 1, jQuery.cache[2].events.click[1].guid == 3；存储了一个type＝“click”；存储了一个事件处理函数handler，参见上图底部，是content元素绑定得第一个click事件的处理函数。</li>
<li>那回到最外层，每个object的直接子元素handle是干什么用的？通过打印的内容可见，其方法体内调用了jQuery.events.dispatch事件。事实上，每个object对象都有一个handle作为入口监听函数，当浏览器触发事件时，入口监听函数被调用，该函数从事件缓存对象events中获取绑定到此元素上的对应的事件处理函数，然后执行。</li>
</ul>
<p>问题来了，jQuery.cache中没有存储任何与页面元素有关的信息，其中的1、2、3是如何对应到DOM元素的？一定在什么地方给DOM元素设置了自定义属性存储了其ID值。</p>
<p><img src="/img/jsevent2.png" alt="jQuery事件系统"></p>
<p>如上图所示，代码来源于jQuery.event.add方法，给派发函数传递的第一个参数当前的DOM元素已经有一个自定义属性jQueryXXXX==2，接下来寻找何处设置了这个自定义属性。</p>
<pre><code>jQuery.event = {

    add: <span class="function"><span class="keyword">function</span><span class="params">( elem, types, handler, data, selector )</span> {</span>

        <span class="keyword">var</span> elemData, eventHandle, events,
            t, tns, type, namespaces, handleObj,
            handleObjIn, handlers, special;

        <span class="comment">//通过jQuery._data给当前DOM元素设置自定义数据</span>
        <span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || ... || !(elemData = jQuery._data( elem )) ) {
            <span class="keyword">return</span>;
        }
        ......
    }
}

jQuery.extend({
    data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data, pvt)</span> {</span>

        <span class="keyword">var</span> thisCache, ret,
            internalKey = jQuery.expando, <span class="comment">//这个自定义属性来自与expando，这是什么东西？？</span>
            getByName = <span class="keyword">typeof</span> name === <span class="string">"string"</span>,

        <span class="keyword">if</span> ( !id ) {
            <span class="comment">// 给DOM元素设置一个unique ID，以获取全局的数据缓存对象中的对应数据</span>
            <span class="keyword">if</span> ( isNode ) {
                elem[ internalKey ] = id = jQuery.deletedIds.pop() || ++jQuery.uuid;
            } <span class="keyword">else</span> {
                id = internalKey;
            }
        }
        ......
    },
    _data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> {</span>
        <span class="keyword">return</span> jQuery.data( elem, name, data, <span class="literal">true</span> );
    },
},
</code></pre><p>好，我们知道了DOM元素的ID与jQuery.cache中的对象ID是一一对应的，在派发函数dispatch中通过种对应关系就能方便地找到当前DOM元素所绑定的事件从而执行。不过，顺着这个线索也遗留了一些问题，比如jQuery.expando是什么？jQuery.data除了DOM ID还设置了那些属性？事件派发函数中对于子元素的click事件冒泡到父元素是如何处理的？且听下回分解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>jQuery事件系统并没有将事件监听函数直接绑定到DOM元素上，而是基于数据缓存系统管理监听函数的。举一个简单的栗子看一下何为数据缓存系统：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span]]>
    </summary>
    
      <category term="jQuery event 事件 数据缓存 W3C 浏览器" scheme="http://yoursite.com/tags/jQuery-event-%E4%BA%8B%E4%BB%B6-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98-W3C-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery事件系统一]]></title>
    <link href="http://yoursite.com/2014/10/10/js-event1/"/>
    <id>http://yoursite.com/2014/10/10/js-event1/</id>
    <published>2014-10-10T09:16:59.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>说到Javascript事件，脑海中闪现的是最初做简单网页时写个button，注册个onclick事件，就出现了简单的交互。那么onclick，和后续接触到的原生JS中的DOM0、DOM2、addEventListener、attachEvent、jQuery中的bind、live、delegate、on等是什么关系，如何演化的。一个简单的onclick为什么会发展成复杂的jQuery事件系统以及数据缓存系统。今天只是一个引子：</p>
<h2 id="DOM0级事件系统">DOM0级事件系统</h2>
<pre><code>document.getElementById(<span class="string">"btn"</span>).onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    alert(<span class="built_in">arguments</span>.length);
}
</code></pre><p>这是是最简单的绑定事件的方式。再早之前就是元素标签内绑定事件，不推荐这种样式行为混在一起的写法。</p>
<p>优势：<br>简单稳定，浏览器兼容；处理事件时，this关键字处理的是当前元素，这很有帮助。<br>劣势：<br>1、只允许元素每次绑定一个回调，重复绑定会覆盖之前的绑定。<br>2、在IE下回调没有参数，在其他浏览器下回调的第一个参数是事件对象。上述代码在IE下弹出0，而在Firefox下弹出1，这个参数就是event对象。<br>3、只能在事件冒泡中运行，而非捕获或冒泡。</p>
<h2 id="DOM2级事件系统">DOM2级事件系统</h2>
<p>IE：</p>
<pre><code>element.attachEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">callback</span>); //绑定事件</span>
element.detachEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">callback</span>); //解除绑定</span>
document.createEventObject(); <span class="comment">//创建事件</span>
element.fireEvent(<span class="class"><span class="keyword">type</span>, <span class="title">event</span>); //派发事件</span>
</code></pre><p>优势：<br>可绑定多个事件，不会覆盖<br>劣势：<br>1、回调函数中this不是指向被绑定元素，而是window<br>2、同种事件绑定多个回调时，回调并不是按照绑定时的顺序依次触发（这还真是头一次听说）<br>3、event事件对象仅存在于window.event参数中，其属性与W3C的有很大差异，比如currentTarget<br>4、事件必须以onXXX形式，仅IE可用<br>5、只支持冒泡</p>
<p>W3C：</p>
<pre><code><span class="keyword">element</span>.addEventListener(type, callback, [phase]);<span class="comment"> //绑定事件</span>
<span class="keyword">element</span>.removeEventListener(type, callback, [phase]);<span class="comment"> //解除绑定</span>
<span class="keyword">element</span>.createEvent(types);<span class="comment"> //创建事件</span>
event.initEvent();<span class="comment"> //初始化事件</span>
<span class="keyword">element</span>.dispatchEvent(event);<span class="comment"> //派发事件</span>
</code></pre><p>优势：<br>1、同时支持事件处理的捕获和冒泡阶段，事件阶段取决于参数设置<br>2、事件处理函数内部，this引用当前元素<br>3、事件对象总是可以通过处理函数的第一个参数获取<br>4、可以绑定多个事件</p>
<p>劣势：其他标准浏览器的实现也有不一致的地方，比如firefox不支持focusin、focus事件，第三四五个参数的使用，事件成员对象的不稳定，如safari下event.target可能时返回文本节点。</p>
<p>为了兼容浏览器，我们通常会创建一个统一的方法，在方法内部通过特性检测分别调用不用的事件模型。</p>
<pre><code><span class="comment">//绑定事件</span>
<span class="keyword">function</span> addEvent(el, <span class="class"><span class="keyword">type</span>, <span class="title">callback</span>, <span class="title">useCapture</span>){</span>
    <span class="keyword">if</span>(el.addEventListener){<span class="comment">//W3C方式优先</span>
        el.addEventListener(<span class="class"><span class="keyword">type</span>, <span class="title">callback</span>, !!<span class="title">useCapture</span>);</span>
    }
    <span class="keyword">else</span>{
        el.attachEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">callback</span>);</span>
    }
}
<span class="comment">//移除事件</span>
<span class="keyword">function</span> removeEvent(el, <span class="class"><span class="keyword">type</span>, <span class="title">callback</span>, <span class="title">useCapture</span>){</span>
    <span class="keyword">if</span>(el.removeEventListener){<span class="comment">//W3C方式优先</span>
        el.removeEventListener(<span class="class"><span class="keyword">type</span>, <span class="title">callback</span>, !!<span class="title">useCapture</span>);</span>
    }
    <span class="keyword">else</span>{
        el.detachEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">callback</span>);</span>
    }
}
<span class="comment">//派发事件</span>
<span class="keyword">function</span> fireEvent(el, <span class="class"><span class="keyword">type</span>){</span>
    <span class="keyword">if</span>(el.createEvent){
        event = document.createEvent(<span class="string">"HTMLEvents"</span>);
        event.initEvent(<span class="class"><span class="keyword">type</span>, <span class="title">true</span>, <span class="title">true</span>);</span>
        el.dispatchEvent(event);
    }
    <span class="keyword">else</span>{
        event = document.createEventObject();
        el.fireEvent(<span class="string">"on"</span> + <span class="class"><span class="keyword">type</span>, <span class="title">event</span>);</span>
    }
}
<span class="comment">//延伸</span>
<span class="comment">//阻止冒泡的通用函数</span>
<span class="keyword">function</span> stopBubble(e){
    <span class="keyword">if</span>(e &amp;&amp; e.stopPropagation){ <span class="comment">//W3C方式</span>
        e.stopPropagation();
    }
    <span class="keyword">else</span>{
        window.event.cancelBubble = <span class="keyword">true</span>; <span class="comment">//IE</span>
    }
}
<span class="comment">//阻止浏览器默认行为的通用函数</span>
<span class="keyword">function</span> stopDefault(){
    <span class="keyword">if</span>(e &amp;&amp; e.preventDefault){ <span class="comment">//W3C方式</span>
        e.preventDefault();
    }
    ele{
        window.event.returnValue = <span class="keyword">false</span>; <span class="comment">//IE</span>
    }
}
</code></pre><p>fireEvent与调用onClick的区别：<br>派发事件fireEvent模拟用户行为触发事件，如触发一个button的onclick事件，如果该button未注册onclick事件也不会报错，并且会引发冒泡，触发其父类中的onclick事件，更贴近用户真实的触发行为。那如果直接调用onclick()呢？如果在未注册onclick事件时调用onclick将会报错“对象不支持此属性或方法”。</p>
<h2 id="Dean_Edward_&amp;&amp;_event-js">Dean Edward &amp;&amp; event.js</h2>
<p>鉴于DOM2级事件系统的缺陷，Dean Edward提出了更完美的解决方案，成为jQuery事件系统的源头，看它是不是长了三头六臂，代码来自<a href="http://dean.edwards.name/weblog/2005/10/add-event/" target="_blank" rel="external">http://dean.edwards.name/weblog/2005/10/add-event/</a></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span><span class="params">(element, type, handler)</span> {</span>
    <span class="comment">// 为每一个事件处理函数分派一个唯一的ID，方便移除</span>
    <span class="keyword">if</span> (!handler.$$guid) handler.$$guid = addEvent.guid++;
    <span class="comment">// 为元素的事件类型创建一个空对象，保存所有类型的回调</span>
    <span class="keyword">if</span> (!element.events) element.events = {};
    <span class="comment">// events对象包含多个type/handlers这样的键值对</span>
    <span class="keyword">var</span> handlers = element.events[type];
    <span class="keyword">if</span> (!handlers) {
        handlers = element.events[type] = {};
        <span class="comment">// 如果元素之前以onXXX的形式绑定过事件，则存储起来</span>
        <span class="keyword">if</span> (element[<span class="string">"on"</span> + type]) {
            handlers[<span class="number">0</span>] = element[<span class="string">"on"</span> + type];
        }
    }
    <span class="comment">// 保存当前的事件处理函数</span>
    handlers[handler.$$guid] = handler;
    <span class="comment">// 指定一个全局的事件处理函数来做所有的工作</span>
    element[<span class="string">"on"</span> + type] = handleEvent;
};
<span class="comment">// 事件处理函数ID计数器</span>
addEvent.guid = <span class="number">1</span>;

<span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span><span class="params">(element, type, handler)</span> {</span>
    <span class="comment">// 从events对象移除当前事件处理函数/函数类型</span>
    <span class="keyword">if</span> (element.events &amp;&amp; element.events[type]) {
        <span class="keyword">delete</span> element.events[type][handler.$$guid];
    }
};

<span class="comment">//统一的事件处理函数入口</span>
<span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span><span class="params">(event)</span> {</span>
    <span class="keyword">var</span> returnValue = <span class="literal">true</span>;
    <span class="comment">// 获取原生的事件对象</span>
    event = event || fixEvent(window.event);
    <span class="comment">// 从元素的事件对象上获取事件处理函数</span>
    <span class="keyword">var</span> handlers = <span class="keyword">this</span>.events[event.type];
    <span class="comment">// 遍历执行事件处理函数</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> handlers) {
        <span class="keyword">this</span>.$$handleEvent = handlers[i];
        <span class="keyword">if</span>(<span class="keyword">this</span>.$$handleEvent(event)===<span class="literal">false</span>){
            returnValue = <span class="literal">false</span>;
        };
    }
};
<span class="comment">//为IE的事件对象做简单的修复</span>
<span class="function"><span class="keyword">function</span> <span class="title">fixEvent</span><span class="params">(event)</span> {</span>
    <span class="comment">//添加标准的W3C方法</span>
    event.preventDefault = fixEvent.preventDefault;
    event.stopPropagation = fixEvent.stopPropagation;
    <span class="keyword">return</span> event;
};
fixEvent.preventDefault = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.returnValue = <span class="literal">false</span>;
};
fixEvent.stopPropagation = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.cancelBubble = <span class="literal">true</span>;
};
</code></pre><p>特点：<br>1、没有对象检测，因为使用最通用的原始的onXXX绑定，不使用addEventListener/attachEvent<br>2、保持正确的this指向<br>3、传递了正确的event对象<br>4、完全跨浏览器包括IE4或NS4<br>5、不会引发内存泄漏（使用者发现onXXX在IE存在不可消弭的内存泄漏）</p>
<p>jQuery在这个版本基础上吸收了“每个处理函数分配一个unique ID，所有回调放到一个对象上存储”的建议，出现了jQuery的数据缓存系统，同时舍弃了onXXX方式，仍然使用addEventListener/attachEvent绑定事件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说到Javascript事件，脑海中闪现的是最初做简单网页时写个button，注册个onclick事件，就出现了简单的交互。那么onclick，和后续接触到的原生JS中的DOM0、DOM2、addEventListener、attachEvent、jQuery中的bind、]]>
    </summary>
    
      <category term="jQuery event 事件 数据缓存 W3C 浏览器" scheme="http://yoursite.com/tags/jQuery-event-%E4%BA%8B%E4%BB%B6-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98-W3C-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<回到顶部>功能该谁做]]></title>
    <link href="http://yoursite.com/2014/09/03/per-gototop/"/>
    <id>http://yoursite.com/2014/09/03/per-gototop/</id>
    <published>2014-09-03T05:24:37.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>当我用Macbook浏览长网页的时候，拉着拉着就得找&lt;回到顶部&gt;按钮。如果网页没有这个功能，就得自己拖回滚动条。为了更美观不碍眼，滚动条早已在不用的时候就隐藏起来，需要上下移动网页才显示，再将鼠标移动到小窄条上，左右手配合拖回顶部，真费劲。还不如在网页的鼠标右键上增加&lt;回到顶部&gt;的功能，单手操作两次点击即可。不如来个彻底，将&lt;回到顶部&gt;功能交给浏览器来做，顺便做个快捷键，也免得前端开发人员到处搞个&lt;回到顶部&gt;，或者什么时候闲来无事，搞个浏览器插件gotoTop，看看有没有人用。<a id="more"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我用Macbook浏览长网页的时候，拉着拉着就得找&lt;回到顶部&gt;按钮。如果网页没有这个功能，就得自己拖回滚动条。为了更美观不碍眼，滚动条早已在不用的时候就隐藏起来，需要上下移动网页才显示，再将鼠标移动到小窄条上，左右手配合拖回顶部，真费劲。还不如在网页的鼠标右键上增加&lt;回到顶部&gt;的功能，单手操作两次点击即可。不如来个彻底，将&lt;回到顶部&gt;功能交给浏览器来做，顺便做个快捷键，也免得前端开发人员到处搞个&lt;回到顶部&gt;，或者什么时候闲来无事，搞个浏览器插件gotoTop，看看有没有人用。]]>
    
    </summary>
    
      <category term="浏览器,回到顶部" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8,%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[香港之行]]></title>
    <link href="http://yoursite.com/2014/08/18/per-hk/"/>
    <id>http://yoursite.com/2014/08/18/per-hk/</id>
    <published>2014-08-18T15:40:58.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>不想流水账一样写一篇攻略，如果有需要咨询的同学可以留言，必将知无不言，言无不尽。不想写”香港是自由与信念的国度“这样上纲上线的文章，只是就自己的所见发表一些所感。之前大Boss说我的视野有限，再不出去见识见识，就无法跟我交流了。我转了一圈回来了，恐怕也不能如他所愿感受到“外面的世界很精彩”。</p>
<p><img src="/img/HK1.jpg" alt="车窗外的风景"></p>
<p>自由：</p>
<p>说了不说还得说。自由是入关时让我摘下胸前背的双肩包检查是否怀孕。自由是进入地铁不再安检，也没有人在你身前身后探来探去。自由是地铁庞大的广告牌上写着“2017年要人手一票实现普选否则占领中环”。自由是路边书摊各种大陆政治内幕。不愧是当过英国殖民地，像是过给了有钱人家的孩子，现在回来了要求家长像有钱人家那样礼遇他。自由是社会进步的标识，我们被禁锢惯了，就皮实了，捏一下打一下也不还手，他们就很矫情，碰一下就叫。而在他们看来，我们又是什么人？没见过世面的乡巴佬，蹑手蹑脚地遵守规则。那又怎么样，自由迟早会有，你们只是走在前面而已。</p>
<p>寸土寸金：</p>
<p>香港真是一个寸土寸金的地方，我们住在红茶馆酒店，设施很完善，过道很狭小，同时只能容纳一个人通过。很多店铺也很小，打开大众点评app，选一个美食排名前三甲的餐厅好好挥霍一下，进去一看，小得还不如庆丰包子铺。</p>
<p><img src="/img/HK2.jpg" alt="维多利亚港"></p>
<p>美食：</p>
<p>吃了港式美食，我都汗颜觉得之前吃的怎么这么糙呢。就说那$86一碗的蟹黄粥，真的超级超级好吃。大米粥（号称白粥）里面放了青菜、虾仁、螃蟹和散落的蟹黄，尤其是蟹黄特别好吃。之前吃粥就是吃粥，顶多几种豆类的混合，绿豆粥、南瓜粥、大米粥、小米粥，谁家还往粥里放大螃蟹呀。搞个粥都这么复杂。说到复杂，我有一次随便吃了一个餐馆的“龙凤球”，面相更像是糖醋里脊，终于吃到一个内地菜了就很兴奋，吃着吃着内容就来了。挑起一块“里脊”，吃到里面是鸡肉，再挑一块，鱼肉，原来是这么个龙凤球。再说说配菜，洋葱、青辣椒、红辣椒、黄辣椒、菠萝块，我了个去，辣椒都配了三种，还放水果。真替厨师麻烦。</p>
<p><img src="/img/HK3.jpg" alt="蟹黄粥"></p>
<p>化妆品：</p>
<p>大街小巷到处都是卓悦、莎莎，这两家是化妆品零售店，包含国内各大专柜品牌的产品，但是价格低很多。她们就像从商场专柜无数闪光灯下走入一排排货架。一直没舍得买的“神仙水”就被放在货架底排一个角落。店里人多拥挤，听口音大多数是大陆人来扫货。像雪肌精、契尔氏这些大牌水水也就2、3百港币，感觉以前买的都被坑了似的，真是冤大头。街上的女孩皮肤都很好，如果我在这遍地都是化妆品店，用雅思兰黛跟用妮维雅一样普及的地方，我皮肤不好才怪呢。除了化妆品，还有很多奢侈品，手表、箱包、首饰，有一家店门口排了很长的队还有工作人员维持秩序，是为了给顾客更好的服务限制了进店人数，你猜大家排着队给人家送钱的店是啥？————香奈儿。脑子都进水了，刷卡都不要钱啊。</p>
<p><img src="/img/HK4.jpg" alt="化妆品"></p>
<p>排队：</p>
<p>这次经历了史上最长时间的排队，都想发誓再也不去人多的地方了。这悲惨的一天是在海洋公园度过的，早上出了地铁需要坐一趟巴士才能到海洋公园，沿着队走啊走啊都找不到队尾，快围了一大圈了，应该出门右转也许能近些。海洋公园里的热门项目均排队时间为2小时，这些都不说。天公不作美的是下午5点半准备出园的时候天降大雨。公园分为“高峰乐园”和“海滨乐园”两大主要景区，以登山缆车和海洋列车连接，上午我们坐缆车到“海滨乐园”，出园的时候需要回到”高峰乐园“，雨大缆车不能开放，只能排队坐海洋列车。我们在大雨里排了2个多小时，人挤人打伞也不管用，每个人的伞都挤得重叠，水顺着伞沿流到衣服里，只有内衣还算干的。7点半左右出园了，没想到搭巴士回去还要排很长的队，都快绝望了。</p>
<p><img src="/img/HK5.jpg" alt="化妆品"></p>
<p>这里面有一个细节，港人很多地方都主动排队，只有两三个人等巴士都会排队，这次队又长得看不到尾巴，就有很多插队的人，但是都被工作人员阻止，队里的人也会帮助维持秩序。有人插到我们的前面，工作人员劝说无效，我后面的哥们说“拉他出来，拉他出来，要去后面排队”。工作人员便拉他出来了，有些插队的人拉都拉不动，都在雨里淋了几个小时谁不想早点回家。然后在一个拐弯处我们这段队伍不知怎么搞得整个就插到前面去了，工作人员立即阻止但来不及了，只是阻止了很后面那一段。我后面那哥们不一样捡了个便宜嘛，怎么不见他说话了。</p>
<p>好吧，啰嗦至此，香港还是他们的，我们只有大陆。</p>
<p><img src="/img/HK6.jpg" alt="海洋公园"></p>
<p><img src="/img/HK7.jpg" alt="迪士尼乐园"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不想流水账一样写一篇攻略，如果有需要咨询的同学可以留言，必将知无不言，言无不尽。不想写”香港是自由与信念的国度“这样上纲上线的文章，只是就自己的所见发表一些所感。之前大Boss说我的视野有限，再不出去见识见识，就无法跟我交流了。我转了一圈回来了，恐怕也不能如他所愿感受到“外]]>
    </summary>
    
      <category term="香港 攻略" scheme="http://yoursite.com/tags/%E9%A6%99%E6%B8%AF-%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[休假还是治疗？]]></title>
    <link href="http://yoursite.com/2014/07/26/per-rest/"/>
    <id>http://yoursite.com/2014/07/26/per-rest/</id>
    <published>2014-07-25T16:04:40.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>在我正式休长假之前，有几周是双休的，为了缓和三年来的单休日子，让身体和心态从满负荷到倍轻松有一个缓冲。只是我有一个隐忧：周一正式开始工作的时候，总是需要1～2小时的“代入”，想一个很熟悉的CSS属性也慢了几秒钟。也许这是由休息进入工作状态避免不了的消耗。那休长假玩疯了之后如何开始工作？如何准备面试？认真地思考这个问题，是从我被电话面试问到我都面试过别人很多遍的必备技能时却语无伦次开始。我相信，我能回答的问题确实是我大脑深处印象最深的经历，不需要任何准备和“代入”便脱口而出，就像存储到大脑内存中一样。而我无法在任意时间内均可以解释清楚的问题是一遍又一遍备份到大脑硬盘中的，所以它不能像在内存中一样快速读取。</p>
<p>我想说的重点是两个:</p>
<blockquote>
<ul>
<li><p>这样的电话面试不公平。面试者是有所准备的，被面试者是处于任意状态下的。不得不说一个很励志的场景，在一节在线托福口语班上，老师把话筒给了一个愿意在1000人的倾听下回答问题的学生，话筒切换之后听到一个小baby用着哭腔不停地呼唤着“妈妈”，这位“妈妈”学生边小声安抚着baby、边说了近一分钟的英语。就是说，你无法知道对方所处的状态，试想，一个人怎么能快速从满脑子想着小孩的状态切换到前端技术交流，当然你想着别的事情也是这样的。所以最好电话面试也要预约时间，或者被面试者直接婉拒，稍作准备后再接受。</p>
</li>
<li><p>枕戈待旦。前端攻城师们真的要人如其名一样的枕戈待旦时刻准备攻城吗？我觉得最好是。我们在高中埋头苦海时家长说考上大学就轻松了，轻轻松松地上着大学然后就迎来了人山人海的就业大军，终于对工作可以轻松应对的时候发现囊中羞涩一平米也买不了。我们不再是相信考上大学就轻松的懵懂少年了，所以你最好也相信，休假不是只有玩，还要准备，时刻准备着。</p>
</li>
</ul>
</blockquote>
<p>最近迷上一部美剧《24小时》——放心，我没有在转移话题——每一季24集与现实时间同步地演绎24小时内发生的事情，每季间隔1～2年。主人公Jack Baver是一名反恐外勤人员，一名冷酷叛逆果断绝敢的冷血特工。每一季结束后他或者是被辞职过起寻常生活，或者是隐形埋名流浪天涯，或者是转去做文职，或者是被关进中国监狱，等到下一季他再出山，也完全是个身体素质极好枪法极准头脑极敏锐的特工。没有大腹便便没有身材发福没有技能退步，这真的是电视剧啊！</p>
<p><strong>那么如何时刻准备着呢？为什么有些记忆近在内存，有些记忆远在硬盘呢？</strong></p>
<p>借鉴一下我最近背单词的感悟，背单词有三种方法：</p>
<blockquote>
<ul>
<li><p>重复记忆，这在我最开始学英语和日语时都得到了验证。初中英语老师要求每天写一篇16开纸的单词，写了三年。学日语一年之后为准备日语等级考试而背单词，每天按照记忆曲线重复背诵之前的内容，并开辟新的内容，大部分时间花费在重复以往上。小孩子学数数一定也是家长一遍又一遍地教才能数出来。这种方法试用于初学者，或者需要在有限时间内快速达到效果的时候。现在背托福词汇就是这样，每天花费1个小时快速浏览1200个单词。单词不是背出来的，是重复出来的。</p>
</li>
<li><p>词根词缀法，比如pre这个词缀是预先的意思，那么你很容易就能背诵preview、previous。我很少用这种方法，因为大部分词汇都是重复出来的，有一定的词汇量之后才总结出各个词缀的意义，然后类推其他的时候也没有很管用。就像汉字的偏旁部首一样，你认识了“日”，又通过象形法“日”下画一条地平线就成了“旦”意味着早晨。但当你看到“但”这个字时还是不知道什么意思。</p>
</li>
<li><p>联想记忆法，第一次学习／bus／这个单词时，你肯定在音标上写着／爸丝／这样的汉字，可能还有很多种／XX丝（死）／。将陌生的知识与已有经验经历建立对应关系，哪怕它们属于不同的知识体系，没有任何逻辑关系，只是方便记忆而已。</p>
</li>
</ul>
</blockquote>
<p><strong>那么如何能够在长期的非工作期间保持对前端知识和工作经验的快速反应？</strong></p>
<p>首先是重复，利用长假时间定期将以往的总结文档、收藏文章浏览一遍。其次保持思考，我们都加入过几个技术交流QQ群、也订阅过几个技术分享公众平台，诚实地说，我只是看一眼他们在说什么，并没有仔细思考他们提出的问题。大脑的懒惰就像是一个天然的屏障，将你与真知隔绝。而重复记忆法恰恰给大脑的懒惰找了一个冠冕堂皇的接口，就像是在说“不思考没关系，多看几遍就可以了”。从这个意义上来说，重复是个笨方法，思考才是捷径。文艺地说，时间可以治愈一切，任何事物都有遗忘的过程，重复是必备技能，而思考可以减缓遗忘，使重复的周期更长一些。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我正式休长假之前，有几周是双休的，为了缓和三年来的单休日子，让身体和心态从满负荷到倍轻松有一个缓冲。只是我有一个隐忧：周一正式开始工作的时候，总是需要1～2小时的“代入”，想一个很熟悉的CSS属性也慢了几秒钟。也许这是由休息进入工作状态避免不了的消耗。那休长假玩疯了之后如]]>
    </summary>
    
      <category term="哲理 感悟" scheme="http://yoursite.com/tags/%E5%93%B2%E7%90%86-%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[雅虎科技频道纯图片布局的实现（下）]]></title>
    <link href="http://yoursite.com/2014/06/30/web-yahootech2/"/>
    <id>http://yoursite.com/2014/06/30/web-yahootech2/</id>
    <published>2014-06-30T05:06:38.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/yahooTech1.jpg" alt="雅虎科技"></p>
<p>上一篇主要从外观上介绍了YahooTech的布局方式，本篇着重代码实现。代码实现经历了两个版本，以下是V1.0的算法：</p>
<p>1、 每张图片的宽度都设置为百分比，当屏幕resize时不需要额外处理。<br>2、 受启发于媒体查询根据屏幕宽度设置多种区间匹配样式，故设置0~320、320~1024、1024～1600、1600~+∞四个区间。</p>
<p>0~320：手机设备，每行只显示一个</p>
<p>320~1024：平板设备，每行显示二个或三个。第一个宽度为30~60%，第二个宽度为20~30%，或是当第一个宽度大于50%时，第二个占满该行。否则第三个占满该行。</p>
<p>1024~1600：桌面，每行显示三个或四个，类似上面的随机取值。</p>
<p>1600~+∞：超大宽屏，每行显示width/400张图片，每张图片宽度为350~450的随机值。</p>
<p>3、根据每张图片的实际宽高和显示宽度百分比计算其显示高度，并在当前行布局完成时取得当前行所有图片的最小显示高度作为当前行的显示高度。</p>
<pre><code>insertItem : <span class="function"><span class="keyword">function</span><span class="params">(item)</span>
{</span>
    <span class="keyword">var</span> divItem = $(item);
    <span class="keyword">var</span> randomWidth = <span class="number">0</span>;
    <span class="comment">//手机端每行只显示一个</span>
    <span class="keyword">if</span>(G_layout_options.clientW &lt;= <span class="number">320</span>){
        randomWidth = <span class="number">100</span>;
        <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
        <span class="keyword">this</span>.fullNum = <span class="number">1</span>;
    }
    <span class="comment">//pad端每行显示二个或三个</span>
    <span class="keyword">else</span> <span class="keyword">if</span>(G_layout_options.clientW &lt;= <span class="number">1024</span>){
        <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">0</span>){
            randomWidth = <span class="built_in">Math</span>.random() * (<span class="number">60</span> - <span class="number">30</span>) + <span class="number">30</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">1</span>){
            <span class="keyword">if</span>(<span class="built_in">parseInt</span>(<span class="keyword">this</span>.itemsWidth[<span class="number">0</span>]) &lt; <span class="number">50</span>){
                randomWidth = <span class="built_in">Math</span>.random() * (<span class="number">30</span> - <span class="number">20</span>) + <span class="number">20</span>;
            }
            <span class="keyword">else</span>{
                randomWidth = <span class="number">100</span> - <span class="keyword">this</span>.itemsWidth[<span class="number">0</span>];
                <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
                <span class="keyword">this</span>.fullNum = <span class="number">2</span>;
            }
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">2</span>){
            randomWidth = <span class="number">100</span> - <span class="keyword">this</span>.itemsWidth[<span class="number">0</span>] - <span class="keyword">this</span>.itemsWidth[<span class="number">1</span>];
            <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
            <span class="keyword">this</span>.fullNum = <span class="number">3</span>;
        }
    }
    <span class="comment">//desktop显示三个或四个</span>
    <span class="keyword">else</span> <span class="keyword">if</span>(G_layout_options.clientW &lt;= <span class="number">1600</span>){
        <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">0</span>){
            randomWidth = <span class="built_in">Math</span>.random() * (<span class="number">40</span> - <span class="number">20</span>) + <span class="number">20</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">1</span>){
            <span class="keyword">if</span>(<span class="built_in">parseInt</span>(<span class="keyword">this</span>.itemsWidth[<span class="number">0</span>]) &lt; <span class="number">30</span>){
                randomWidth = <span class="built_in">Math</span>.random() * (<span class="number">30</span> - <span class="number">20</span>) + <span class="number">20</span>;
            }
            <span class="keyword">else</span>{
                randomWidth = <span class="built_in">Math</span>.random() * (<span class="number">40</span> - <span class="number">30</span>) + <span class="number">30</span>;
            }
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">2</span>){
            <span class="keyword">if</span>(<span class="built_in">parseInt</span>(<span class="keyword">this</span>.itemsWidth[<span class="number">0</span>] + <span class="keyword">this</span>.itemsWidth[<span class="number">1</span>]) &lt; <span class="number">60</span>){
                randomWidth = <span class="built_in">Math</span>.random() * (<span class="number">30</span> - <span class="number">20</span>) + <span class="number">20</span>;
            }
            <span class="keyword">else</span>{
                randomWidth = <span class="number">100</span> - <span class="keyword">this</span>.itemsWidth[<span class="number">0</span>] - <span class="keyword">this</span>.itemsWidth[<span class="number">1</span>];
                <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
                <span class="keyword">this</span>.fullNum = <span class="number">3</span>;
            }
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length == <span class="number">3</span>){
            randomWidth = <span class="number">100</span> - <span class="keyword">this</span>.itemsWidth[<span class="number">0</span>] - <span class="keyword">this</span>.itemsWidth[<span class="number">1</span>] - <span class="keyword">this</span>.itemsWidth[<span class="number">2</span>];
            <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
            <span class="keyword">this</span>.fullNum = <span class="number">4</span>;
        }
    }
    <span class="comment">//超大屏</span>
    <span class="keyword">else</span>{
        <span class="keyword">this</span>.fullNum = <span class="built_in">parseInt</span>(G_layout_options.contentW / <span class="number">400</span>);
        <span class="keyword">if</span>(<span class="keyword">this</span>.itemsWidth.length &lt; <span class="keyword">this</span>.fullNum - <span class="number">1</span>){
            randomWidth = (<span class="built_in">Math</span>.random() * (<span class="number">450</span> - <span class="number">350</span>) + <span class="number">350</span>) / G_layout_options.contentW * <span class="number">100</span>;
        }
        <span class="keyword">else</span>{
            <span class="keyword">var</span> itemsWidthSumTmp = <span class="number">0</span>;
            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.itemsWidth.length; i++){
                itemsWidthSumTmp += <span class="keyword">this</span>.itemsWidth[i];
            }
            randomWidth = <span class="number">100</span> - itemsWidthSumTmp;
            <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
        }
    }
    <span class="keyword">this</span>.itemsWidth.push(randomWidth);
    divItem.css(<span class="string">"width"</span>, randomWidth + <span class="string">"%"</span>);
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    divItem.appendTo(<span class="keyword">this</span>.element);
    <span class="keyword">this</span>.calcuRowHeight(divItem, randomWidth);
},

calcuRowHeight: <span class="function"><span class="keyword">function</span><span class="params">(divItem, randomWidth)</span>{</span>
        <span class="keyword">var</span> renderHeight = <span class="built_in">parseFloat</span>(divItem.find(<span class="string">"img"</span>).attr(<span class="string">"data-height"</span>)) * (randomWidth * (G_layout_options.contentW - <span class="number">20</span>) - <span class="number">1000</span>) / (<span class="built_in">parseFloat</span>(divItem.find(<span class="string">"img"</span>).attr(<span class="string">"data-width"</span>)) * <span class="number">100</span>);
        <span class="keyword">this</span>.itemsHeight.push(renderHeight);
        <span class="keyword">if</span>(<span class="keyword">this</span>.isFullROW &amp;&amp; <span class="keyword">this</span>.itemsHeight.length == <span class="keyword">this</span>.fullNum){
            <span class="comment">//console.log(this.itemsHeight);</span>
            <span class="keyword">var</span> minHeight = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>,<span class="keyword">this</span>.itemsHeight);
            <span class="keyword">this</span>.element.css({<span class="string">"height"</span>:minHeight &gt; <span class="number">500</span>? <span class="number">500</span>:minHeight});
            <span class="comment">//每行显示两个时重新取bigger类型图片</span>
            <span class="keyword">if</span>(<span class="keyword">this</span>.fullNum == <span class="number">2</span>){
                <span class="keyword">this</span>.element.find(<span class="string">".content-img"</span>).each(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
                    $(<span class="keyword">this</span>).attr(<span class="string">"src"</span>,$(<span class="keyword">this</span>).attr(<span class="string">"src"</span>).replace(<span class="string">"common"</span>,<span class="string">"bigger"</span>));
                })
            }

        }
    }
</code></pre><p>显示效果如下图：</p>
<p><img src="/img/yahooTech3.jpg" alt="立方媒体"></p>
<p>其实这个算法很low，基本上就是一些随机值凑数，被吐槽都是卡卡西风格，这种不顾图片实际宽高而采用随机宽度的做法太不接地气，效果也不好。于是v2.0采用了新的解决方案：</p>
<p>1、 遍历待排列的数据块Blocks，取得一个availableRow，可能是新的一行，也可能是未满行，将当前数据块Block试插入此行。<br>2、 所谓试插入，就是计算新数据插入后的当前行宽度是否超出最大宽度，超出也没有关系，顺势按比例压缩计算试插入的行高。attempHeight = MaxWith/Sum(width/height)。此时设置一个高度边界值300，当行高小于300时影响效果，故试插入失败。其余情况皆为成功。<br>3、 试插入失败意味着当前行剩余空间过小，不适合再插入数据，故创建新行，新行变成了当前行。<br>4、 执行DOM插入操作。<br>5、 重新计算行高，并以此设置图片显示宽高，如果当前图片宽度与需要显示的宽度不符，为避免图片拉伸影响效果可重新获取对应尺寸的图片URL。排列完成后显示当前行。</p>
<p>在此方案中图片宽度使用固定值不再使用百分比，能够更大限度地因图制宜。只是窗口resize时需要重排。最大的亮点是行高的计算的方法：attempHeight = MaxWith/Sum(width/height)，真的是很简单的四则运算提供了一个很大的突破口。</p>
<pre><code>showBlocks : <span class="function"><span class="keyword">function</span><span class="params">(items)</span>
{</span>   
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++)
    {
        <span class="keyword">var</span> block = items[i];
        <span class="keyword">var</span> row = <span class="keyword">this</span>.getAvailableRow();
        <span class="keyword">var</span> rowIndex = row.getRowIndex();
        <span class="keyword">if</span>(!row.attemptInsertBlock(block)){
            row = <span class="keyword">this</span>.createNewRow();
        };
        row.insertBlock(block);
    }
},

getAvailableRow : <span class="function"><span class="keyword">function</span><span class="params">()</span>
    {</span>
        <span class="keyword">var</span> lastRow = <span class="keyword">this</span>.getLastRow();
        <span class="keyword">if</span>(lastRow == <span class="literal">null</span>)
            lastRow = <span class="keyword">this</span>.createNewRow();
        <span class="keyword">else</span>
        {
            <span class="keyword">var</span> enough = lastRow.checkFullRow();
            <span class="keyword">if</span>(enough){
                lastRow = <span class="keyword">this</span>.createNewRow();
            }
        }
        <span class="keyword">return</span> lastRow;
    },

attemptInsertBlock : <span class="function"><span class="keyword">function</span><span class="params">(block)</span>
    {</span>   
        <span class="comment">//边界测试</span>
        <span class="keyword">if</span>(<span class="keyword">this</span>.rowWidth + block.width - <span class="number">10</span> &gt; G_layout_options.contentW){
            <span class="keyword">this</span>.rowWidth = G_layout_options.contentW;
            <span class="keyword">this</span>.attempHeight = (G_layout_options.contentW - (<span class="keyword">this</span>.blockWidths.length + <span class="number">1</span>) * <span class="number">10</span> ) / (<span class="keyword">this</span>.rowRadio + block.aspectRadio);
            <span class="keyword">if</span>(<span class="keyword">this</span>.attempHeight &lt; <span class="number">300</span>){
                <span class="keyword">this</span>.layoutBlock();
                <span class="keyword">return</span> <span class="literal">false</span>;
            }
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
    },

insertBlock : <span class="function"><span class="keyword">function</span><span class="params">(block)</span>
    {</span>
        <span class="comment">//更新视图</span>
        <span class="keyword">this</span>.element.append(block.element);
        <span class="comment">//更新Model</span>
        <span class="keyword">this</span>.blocks.push(block);
        <span class="keyword">this</span>.attempHeight = <span class="keyword">this</span>.attempHeight == <span class="number">0</span>? block.height : <span class="keyword">this</span>.attempHeight;
        <span class="keyword">this</span>.rowWidth += block.width + <span class="number">10</span>;
        <span class="keyword">this</span>.rowRadio += block.aspectRadio;
        <span class="keyword">this</span>.blockWidths.push(block.width);
        <span class="keyword">this</span>.blockHeights.push(block.height);
        <span class="comment">//边界测试</span>
        <span class="keyword">if</span>(<span class="keyword">this</span>.rowWidth - <span class="number">10</span> &gt; G_layout_options.contentW){
            <span class="keyword">this</span>.layoutBlock();
        }
    },

layoutBlock : <span class="function"><span class="keyword">function</span><span class="params">()</span>
{</span>   
    <span class="keyword">this</span>.rowWidth = G_layout_options.contentW;
    <span class="keyword">this</span>.attempHeight = (G_layout_options.contentW - <span class="keyword">this</span>.blockWidths.length * <span class="number">10</span> ) / <span class="keyword">this</span>.rowRadio;
    <span class="comment">//设置行高</span>
    <span class="keyword">this</span>.element.css({<span class="string">"height"</span>:<span class="keyword">this</span>.attempHeight});
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.blocks.length; i++){
        <span class="comment">//更新Model</span>
        <span class="keyword">var</span> _block = <span class="keyword">this</span>.blocks[i];
        _block.setContainer(<span class="keyword">this</span>);
        _block.height = <span class="keyword">this</span>.attempHeight;
        _block.width = _block.aspectRadio * <span class="keyword">this</span>.attempHeight;
        <span class="keyword">if</span>(_block.width &gt; <span class="number">400</span>){
            _block.fetchImage = <span class="literal">true</span>;
            _block.src= _block.src.replace(<span class="string">"common"</span>,<span class="string">"bigger"</span>);
        }
        <span class="comment">//更新视图</span>
        _block.element.find(<span class="string">"img"</span>).attr(<span class="string">"width"</span>,_block.width);
        _block.element.find(<span class="string">"img"</span>).attr(<span class="string">"height"</span>,_block.height);
        <span class="keyword">if</span>(_block.fetchImage){
            _block.element.find(<span class="string">"img"</span>).attr(<span class="string">"src"</span>,_block.src);
        }
    }
    <span class="keyword">this</span>.isFullROW = <span class="literal">true</span>;
    <span class="comment">//显示当前行</span>
    <span class="keyword">this</span>.show();
},
</code></pre><p>效果图如下：</p>
<p><img src="/img/yahooTech4.jpg" alt="立方媒体"></p>
<p>有没有觉得顿时高大上了很多，完整效果请移步：<a href="http://www.l99.com/media/sex" title="立方媒体" target="blank">http://www.l99.com/media/sex</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/yahooTech1.jpg" alt="雅虎科技"></p>
<p>上一篇主要从外观上介绍了YahooTech的布局方式，本篇着重代码实现。代码实现经历了两个版本，以下是V1.0的算法：</p>
<p>1、 每张图片的宽度都设置为百分比，当屏]]>
    </summary>
    
      <category term="YahooTech 雅虎科技 纯图片 横向瀑布流" scheme="http://yoursite.com/tags/YahooTech-%E9%9B%85%E8%99%8E%E7%A7%91%E6%8A%80-%E7%BA%AF%E5%9B%BE%E7%89%87-%E6%A8%AA%E5%90%91%E7%80%91%E5%B8%83%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[鸡血三年 累觉不爱]]></title>
    <link href="http://yoursite.com/2014/06/26/per-resign/"/>
    <id>http://yoursite.com/2014/06/26/per-resign/</id>
    <published>2014-06-26T05:40:12.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>猛然间一抬眼，眼睛虚幻得看不清程哥的脸，才意识到自己应该休息，盯着屏幕太久了；<br>目不转睛思索问题，突然左耳一阵嗡响，才意识到自己应该休息，集中精力太久了；<br>纠结于一个文件的命名或是代码结构不够优雅，论坛上在讨论velocity、underscore、方案选型等千奇百怪的问题，才意识到自己应该休息，归零来看看更广阔的世界；</p>
<p>3年前，为自己从一成不变矮挫丑的软件界面转移到五彩斑斓酷炫拽的web前端而兴奋不已，那种兴奋能让你听一次便记住一个色值、书本上的知识一下子就找到了用武之地，一个F12就能清清楚楚地看到代码的来龙去脉，透明没有伪装。但那时写代码就像滑冰，说不定哪一脚不稳就摔了个底朝天，上线前总会把改过的代码都过一遍，可能出现的问题和解决方法都实验一遍，不能做到百分百无bug也要能尽快修复。真的，每一步都可能摔倒，每一句代码都可能出错。</p>
<p>如果不是眼下前端小妹的代码上线后出现问题导致部分恢复的事情，我已经忘记了当初的如履薄冰。现在骄傲到不指望QA的测试，上线出现问题也义正言辞地说不是代码级别的问题，为了实现类YahooTech的纯图片展示方式，断断续续研究了一个星期YahooTech混淆后的代码（你研究过就知道，那不是人看的），在终于要大功告成的时候窗口resize layout出现问题，花费半个小时用一行代码搞定。一行代码能成事，也能坏事。</p>
<p>哪怕受苦于IE6的折磨都当成一种特别的经历。它像一个黑匣子让你东奔西突，当你煞费苦心花费个把小时终于解决一个IE6的兼容性问题时，无比激动。长此以往便渐渐了解她的脾气秉性，很快写出取悦于她的代码。只是后来，甚是自豪的同时又莫名的惆怅，就像被潜规则之后而上位一样，何苦花大把的时候来适应一个潜规则，却还因此而沾沾自喜。</p>
<p>这三年是我用力工作的三年，什么房子车子票子都抛之脑后，只是享受于午夜更新前灯火通明的办公室里一群打了鸡血的同事，更新后和同事走几公里夜路找出租车。这种无忧无虑又百转千回给了我机遇挑战和自我实现的价值，哪怕最后只收拾一包离开这奉献三年的地方。说着说着有些难受，不舍，就像我们总期盼周杰伦和蔡依林在一起、林志颖娶了林心如该多好实际上是怀念我们自己的初恋一样，我不舍的更是自己一心一意奋斗的青春。</p>
<p>眼下，有点累，什么都不想做，就这么呆着。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>猛然间一抬眼，眼睛虚幻得看不清程哥的脸，才意识到自己应该休息，盯着屏幕太久了；<br>目不转睛思索问题，突然左耳一阵嗡响，才意识到自己应该休息，集中精力太久了；<br>纠结于一个文件的命名或是代码结构不够优雅，论坛上在讨论velocity、underscore、方案选型等千]]>
    </summary>
    
      <category term="立方网 前端 思考" scheme="http://yoursite.com/tags/%E7%AB%8B%E6%96%B9%E7%BD%91-%E5%89%8D%E7%AB%AF-%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网页头部向下滚动隐藏向上滚动显示]]></title>
    <link href="http://yoursite.com/2014/05/29/web-header/"/>
    <id>http://yoursite.com/2014/05/29/web-header/</id>
    <published>2014-05-29T05:45:56.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>这种效果在原生APP中处处可见。向下滚动时意味着用户在寻求更多的内容，同时手机端可视区域有限，故将头部隐藏以展示更多的内容真是一件体验美好的事；向上滚动时，用户可能在寻找其他操作，故显示头部。这本身也是响应式设计的体现。今天，我们尝试把这种效果迁移到web端。</p>
<p><strong>首先、头部固定</strong></p>
<pre><code><span class="tag">body</span> {
  <span class="attribute">padding-top</span><span class="value">: <span class="number">80</span>px;</span> <span class="comment">// 头部高度固定时CSS中设置</span>
}
<span class="tag">header</span> {
  <span class="attribute">background</span><span class="value">:  <span class="hexcolor">#062D52</span>;</span>
  <span class="attribute">position</span><span class="value">: fixed;</span>
  <span class="attribute">top</span><span class="value">: <span class="number">0</span>;</span>
  <span class="attribute">transition</span><span class="value">: top <span class="number">0.2</span>s ease-in-out;</span>
  <span class="attribute">width</span><span class="value">: <span class="number">100</span>%;</span>
  <span class="attribute">box-shadow</span><span class="value">: <span class="number">0</span> <span class="number">3</span>px <span class="number">3</span>px <span class="number">0</span> rgba(<span class="number">6</span>, <span class="number">45</span>, <span class="number">82</span>, <span class="number">0.5</span>);</span> 
  <span class="attribute">z-index</span><span class="value">: <span class="number">999</span>;</span>
}
<span class="class">.nav-up</span> {
  <span class="attribute">top</span><span class="value">: -<span class="number">80</span>px;</span> <span class="comment">//头部高度固定时CSS中设置. </span>
}
</code></pre><p><strong>其次、滚动事件</strong></p>
<pre><code><span class="keyword">var</span> $header = $(<span class="string">"header"</span>);
<span class="keyword">var</span> headerHeight =  $header.height();
<span class="keyword">var</span> lastScrollTop = <span class="number">0</span>;
<span class="keyword">var</span> delta = <span class="number">5</span>;
<span class="keyword">var</span> didScroll;
<span class="comment">//$("body").css({"padding-top": headerHeight});头部高度不固定时JS中设置</span>
$(window).scroll(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    didScroll = <span class="literal">true</span>;
})
setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (didScroll) {
        scrollHeaderStickyEvent();
        didScroll = <span class="literal">false</span>;
    }
}, <span class="number">250</span>);

<span class="function"><span class="keyword">function</span> <span class="title">scrollHeaderStickyEvent</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> st = $(<span class="keyword">this</span>).scrollTop();
    <span class="comment">// 滚动距离过小，未达到最小间距时不处理。</span>
    <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(lastScrollTop - st) &lt;= delta){
        <span class="keyword">return</span>;
    }
    <span class="comment">// 向下滚动超过header部分时增加样式nav-up以隐藏header部分.</span>
    <span class="keyword">if</span> (st &gt; lastScrollTop &amp;&amp; st &gt; headerHeight){
        <span class="comment">// 向下滚动</span>
    $header.addClass(<span class="string">"nav-up"</span>);
    <span class="comment">//$header.css({"top": "-" + headerHeight + "px"}); 高度动态设置   </span>
    } <span class="keyword">else</span> {
        <span class="comment">// 向上滚动</span>
        <span class="keyword">if</span>(st + $(window).height() &lt; $(document).height()) {
            $header.removeClass(<span class="string">"nav-up"</span>);
                <span class="comment">//$header.css({"top": 0}); 高度动态设置</span>
        }
    }
    lastScrollTop = st;
}
</code></pre><p>如此使用250ms的定时器来检测是否在scroll过程中的方式我是第一次使用，而且与我的思考方向正好相反。没有想通它在性能上有什么优势，传统的做法如下：</p>
<pre><code><span class="keyword">var</span> $header = $(<span class="string">"header"</span>);
    <span class="keyword">var</span> headerHeight =  $header.height();
    <span class="keyword">var</span> lastScrollTop = <span class="number">0</span>;
    <span class="keyword">var</span> stickyTimer = <span class="literal">null</span>;
    <span class="keyword">var</span> delta = <span class="number">5</span>;
    <span class="keyword">var</span> didScroll;
    <span class="comment">//$("body").css({"padding-top": headerHeight});头部高度不固定时JS中设置</span>
    $(window).scroll(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span>(stickyTimer != <span class="literal">null</span>){
            clearTimeout(stickyTimer);
            stickyTimer = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
                scrollHeaderStickyEvent();
            },<span class="number">250</span>)
        }
        <span class="keyword">else</span>{
            stickyTimer = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
                scrollHeaderStickyEvent();
            },<span class="number">250</span>)
        }
    }
    <span class="function"><span class="keyword">function</span> <span class="title">scrollHeaderStickyEvent</span><span class="params">()</span>{</span>
        <span class="comment">//同上…….</span>
    }
</code></pre><p>参考资料：<a href="https://medium.com/design-startups/67bbaae9a78c" target="_blank" rel="external">https://medium.com/design-startups/67bbaae9a78c</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这种效果在原生APP中处处可见。向下滚动时意味着用户在寻求更多的内容，同时手机端可视区域有限，故将头部隐藏以展示更多的内容真是一件体验美好的事；向上滚动时，用户可能在寻找其他操作，故显示头部。这本身也是响应式设计的体现。今天，我们尝试把这种效果迁移到web端。</p>
<p]]>
    </summary>
    
      <category term="向上滚动 向下滚动" scheme="http://yoursite.com/tags/%E5%90%91%E4%B8%8A%E6%BB%9A%E5%8A%A8-%E5%90%91%E4%B8%8B%E6%BB%9A%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[雅虎科技频道纯图片布局的实现（上）]]></title>
    <link href="http://yoursite.com/2014/05/14/web-yahootech1/"/>
    <id>http://yoursite.com/2014/05/14/web-yahootech1/</id>
    <published>2014-05-13T16:25:12.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>题外话：希望有一天做东西不再用“仿”这个字。<br>首次看到<a href="https://www.yahoo.com/tech" title="yahooTech" target="blank">雅虎科技</a>的页面，我想到的是这几个词，全屏、大胆、横向瀑布流、随机、没什么大不了的。仔细研究了一下它的页面布局之后，发现了几个细节：</p>
<ol>
<li><p>每行显示的图片数量和布局是否有规律？</p>
<p> 取样了近200条数据，无明显规律。但是大概可以推断一些边界值。如每行显示2张、3张（并列3张、左1右2）、5张（左2中2右1）、6张（左1上三下二），但不限于此。图片宽度范围为300px~1000px，高度范围为260px~620px。每个区块均绝对定位，动态设置宽高和位置。Pinterest的瀑布流很早就使用这种方式定位，对页面元素的控制性更好，而我们更习惯于浮动定位。</p>
<p> 举个形象的故事，就像组织同学们排队，小红你站在（25,25）这个点上，小绿你站在（25+10,25）这个点上，这是绝对定位；同学们按照学号依次排列，中间间隔10cm，这是浮动。浮动不用计算每个人的位置，实现简单，但是常出现一种现象：就是后面的人一拥而上看似排好了但肯定还会陆续往后退。这种体验不好，除非明确每个人的三围，站好了就不要乱动。</p>
<p> 于是，我让她们每个人回家量三围，排队前都贴到衣服后面（等同于让后端获取图片宽高写入html），这样后面的同学会主动预留位置。但是还是有好些同学没有完成任务，忘记啦，家里没有尺子啦，确实量不出来啊等等。我就无语了，先排队吧。小红学号在前面，先入队站好后现场量三围，发现胖了就把后面的同学往后挤挤。小绿学号在后面，还没轮到她的时候她就量好了。所以她就不影响。</p>
<p> 但这影响了我们的班级形象啊，排个队都拖拖拉拉的。小红说，我们家就是没有钱买尺子啊。。。（后端同学说无法取得图片尺寸，鬼才信呢）我只好决定，没有三围的同学不再入列。话扯得有点远了，拉回来。上述的边界值是2014年4月13日统计的，现在布局有些许变化，向着可视区域内图片数量增加的方向改进。</p>
</li>
<li><p>无论如何改变屏幕大小，图片清晰依旧。</p>
<p> 响应式设计中，这种按需要尺寸加载图片的技术必然会普及，那Yahoo对每张图片都提供了那些尺寸呢？经调查，图片宽度从200px-1000px，每隔50／100提供一种尺寸。200、250、300、350、400、450、500、550、600、700、800、900、1000。（试着读一下这些数据，有没有想起《卖拐》里的情景）1000px的图片文件大小得多大啊？！随便看了一张88.4K，只有全屏的背景图我才舍得用100K左右的图片，人家不差网速呀。</p>
</li>
<li><p>图片上的文字遮罩</p>
<p> 图片上显示文字为了显示清晰，常用的解决方案就是给文字增加一层遮罩。这种遮罩过于明显很不美观，而Yahoo使用的是根据图片的主色使用渐变白或渐变黑遮罩，正好与图片很好地融合到一起。</p>
</li>
</ol>
<p>对比看一下YahooTech和两性（床上）版块的实现效果。</p>
<p><img src="/img/yahooTech1.jpg" alt="雅虎科技"></p>
<p><img src="/img/yahooTech2.png" alt="立方媒体"></p>
<p>实现上主要有三个类，简要分析一下代码：</p>
<pre><code><span class="comment">//Manager类，管理Row和DataPool</span>
Class(<span class="string">"RowManager"</span>, com.lifeix.event.Listener, {
    instance : <span class="literal">null</span>,  <span class="comment">//单例</span>
    constructor : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>},
    <span class="comment">//调用入口，从缓冲池DataPool中获取数据传递给showBlocks()</span>
    showMoreBlocks : <span class="function"><span class="keyword">function</span><span class="params">(requiredCount)</span>{</span>}
    <span class="comment">//遍历数据，逐个插入到当前行</span>
    showBlocks : <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    <span class="comment">//获取当前Row，如果当前行数据已满则新建Row</span>
    getAvailableRow: <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    <span class="comment">//新建Row</span>
    createNewRow: <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    ……
}

<span class="comment">//Row类，实现行的基本操作</span>
Class(<span class="string">"Row"</span>, com.lifeix.event.Listener, {
    constructor : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>},
    <span class="comment">//新建一行append到页面中</span>
    init: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}
    <span class="comment">//每行显示二条或三条数据，逐条append到页面中。</span>
    insertItem: <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    <span class="comment">//当前行数据已满时设置，根据图片宽高计算行高。</span>
    calcuRowHeight: <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    ……
}

<span class="comment">//DataPool类，实现缓冲池的基本操作</span>
Class(<span class="string">"DataPool"</span>, com.lifeix.event.Listener, {
    instance : <span class="literal">null</span>, <span class="comment">//单例</span>
    constructor : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>},
    <span class="comment">//将初始化得到的和ajax后续加载的数据均存储到缓冲池DataPool中。</span>
    refresh: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}
    <span class="comment">//发送ajax请求入口，过滤重复请求。</span>
    _loadMore: <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    <span class="comment">//发送ajax请求核心方法，请求后的数据存储到缓冲池DataPool中</span>
    _sendAjaxRequest: <span class="function"><span class="keyword">function</span><span class="params">(items)</span>{</span>}
    <span class="comment">//从缓冲池DataPool中获取指定数量的数据</span>
    getTopItems: <span class="function"><span class="keyword">function</span><span class="params">(num)</span>{</span>}
    ……
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>题外话：希望有一天做东西不再用“仿”这个字。<br>首次看到<a href="https://www.yahoo.com/tech" title="yahooTech" target="blank">雅虎科技</a>的页面，我想到的是这几个词，全屏、大胆、横向瀑布流、随机、]]>
    </summary>
    
      <category term="YahooTech 雅虎科技 纯图片 横向瀑布流" scheme="http://yoursite.com/tags/YahooTech-%E9%9B%85%E8%99%8E%E7%A7%91%E6%8A%80-%E7%BA%AF%E5%9B%BE%E7%89%87-%E6%A8%AA%E5%90%91%E7%80%91%E5%B8%83%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5移动开发中菜单如何左右折叠]]></title>
    <link href="http://yoursite.com/2014/03/29/h5-collapse/"/>
    <id>http://yoursite.com/2014/03/29/h5-collapse/</id>
    <published>2014-03-29T05:02:33.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>最近的工作都转移到移动开发中，针对主站www.l99.com开发一套移动端版本，像之前写的《webapp立方没体诞生之初》、《单页应用中页面转场的实现》都是针对此项目。</p>
<p>借此谈谈对原生APP和HTML5 WEBAPP的看法，关于各有千秋、根据项目需求的说法谁都会说，不能否认的是，HTML5在一段时间内无法与原生APP抗衡，在用户体验、速度、流量上都只能望其项背。但其表现出来的优势也越来越显著，无需审核、无需安装、跨平台（不需开发iphone和android两中版本）。在之前的PC时代，不也是安装各种管理信息系统、杀毒软件、音乐播放工具、输入法等等，而现在越来越倾向于访问网站、在线收听、云服务。这是一个趋势，但是需要多长时间达到成熟的状态还未可知。毕竟Facebook在2012年期间舍弃原本实行的HTML5架构，转而打造原生APP。不过，你可以看到这个趋势的推进，ios7的safari增加了隐藏地址栏和底部导航的功能，使WEBAPP拥有了与原生APP同样的空间。</p>
<p>从开发角度来看，webapp和浏览器依然扮演着同PC端相同的角色，一个负责布局样式功能的代码实现，一个负责解析渲染和交互，这些都只停留在单个页面内，一个url访问一个页面，点击链接跳转到另一页面。而对于页面间的布局和转场还鲜有涉及，没有系统或浏览器接口可供调用。要想达到原生app的体验效果，需要类似一种中间层的解决方案。其实这应该是HTML5持续推进的方向，它增加了<code>&lt;section</code>&gt;<code>&lt;article</code>&gt;<code>&lt;video</code>&gt;<code>&lt;audio</code>&gt;等各种语义化的标签，为什么没有增加<code>&lt;page</code>&gt;?这个标签一出现将会改变单一页面的格局，一个页面可能拥有多个page，并定义多个page的切换效果，浏览器就去实现吧。开发人员就又轻松了。好吧，这些都是意淫，话说回来，现在什么都没有，还是得自己开发呀。今天说说菜单如何左右折叠，效果嘛，原生APP中处处可见。这种把导航菜单折叠后隐藏起来的信息组织方式几乎成了原生APP的设计范式。</p>
<p><img src="/img/collapse1.jpg" alt="facebook"><br>facebook中菜单折叠</p>
<h4 id="bootstrap中有没有此项功能:">bootstrap中有没有此项功能:</h4>
<p>bootsrap是webapp的开发利器，它通过在html上设置自定义属性定制出常见的页面布局和效果，最近的项目也是在bootstrap基础上开发的，所以顺便查找bootstrap是否支持此项功能。事实上，其官网上<a href="http://v3.bootcss.com/javascript/#collapse" target="_blank" rel="external">http://v3.bootcss.com/javascript/#collapse</a>提供了collapse插件，垂直方面上可以折叠和展开。通过调试器能够看出其大体实现原理：<br>1、默认情况下折叠：每个导航包括标题和内容两部分，内容默认隐藏：display：none；height：0；<br>2、点击某个导航：给内容增加动画样式 addClass(“.collapsing”)<br>        .collapsing{height:0;-webkit-transition:height .35s ease;}<br>    同时获取内容高度并设置高度，内容将按照动画样式用时0.35s以慢快慢的速度完成高度从0到指定值的过程。动画完成后删除此样式。</p>
<p>实际上，是CSS3流畅地完成了需要显示的内容的高度变化，将其下方内容挤走。那如何转移为横向的折叠呢？</p>
<h4 id="只有垂直折叠，如何横行折叠">只有垂直折叠，如何横行折叠</h4>
<p>bootstrap的官网实例中没有横向折叠，但是网上也能搜索出利用bootstrap的某个版本（链接地址到github）或者变种（链接到twitter）能够实现横向折叠。如果项目中已经引用了不同的版本或是自定义版本，为了一个效果便替换了新的版本是不可取的，花时间去研究两个版本的不同也不值得，尤其是自定义版本，既然选择了自定义就意味着你得了解它的代码，能够随时添加或修改。实现上也比较简单，可以自己做些修改：</p>
<p><img src="/img/collapse2.jpg" alt="实例图"></p>
<pre><code><span class="class">.viewport</span> {
    <span class="attribute">overflow</span><span class="value">: hidden;</span> <span class="comment">//使页面占满屏幕避免出现横向滚动条</span>
}
<span class="class">.viewport</span> <span class="class">.frame</span> {
  <span class="attribute">width</span><span class="value">: <span class="number">200</span>%;</span>  <span class="comment">//一唱</span>
  <span class="attribute">height</span><span class="value">: auto;</span>
}

<span class="class">.viewport</span> <span class="class">.frame</span> <span class="class">.menu</span> {
  <span class="attribute">height</span><span class="value">: auto;</span>    
}
<span class="class">.viewport</span> <span class="class">.frame</span> <span class="class">.menu</span><span class="class">.collapse</span> {
  <span class="attribute">float</span><span class="value">: left;</span>
  <span class="attribute">height</span><span class="value">: <span class="number">100</span>% <span class="important">!important</span>;</span>
  <span class="attribute">width</span><span class="value">: auto;</span> 
}

<span class="comment">//折叠状态：设置宽度动画，初始宽度为0</span>
<span class="class">.viewport</span> <span class="class">.frame</span> <span class="class">.menu</span><span class="class">.collapse</span><span class="class">.width</span> {
   <span class="attribute">position</span><span class="value">: relative;</span>
  <span class="attribute">width</span><span class="value">:<span class="number">0</span>;</span>
  <span class="attribute">overflow</span><span class="value">: hidden;</span>
  -webkit-<span class="attribute">transition</span><span class="value">: width <span class="number">0.35</span>s ease;</span>
  -moz-<span class="attribute">transition</span><span class="value">: width <span class="number">0.35</span>s ease;</span>
  -o-<span class="attribute">transition</span><span class="value">: width <span class="number">0.35</span>s ease;</span>
  <span class="attribute">transition</span><span class="value">: width <span class="number">0.35</span>s ease;</span> 
}
<span class="comment">//展开状态：动画结束宽度无250px</span>
<span class="class">.viewport</span> <span class="class">.frame</span> <span class="class">.menu</span><span class="class">.collapse</span><span class="class">.widthauto</span>{
    <span class="attribute">width</span><span class="value">:<span class="number">250</span>px;</span>
}

<span class="comment">//左侧导航内容</span>
<span class="class">.viewport</span> <span class="class">.frame</span> <span class="class">.menu</span> <span class="class">.collapse-inner</span> {
  <span class="attribute">position</span><span class="value">: relative;</span>
  <span class="attribute">width</span><span class="value">: <span class="number">250</span>px;</span>
  <span class="attribute">height</span><span class="value">: <span class="number">100</span>%;</span> 
}
<span class="comment">//右侧内容即屏幕中心内容</span>
<span class="class">.viewport</span> <span class="class">.frame</span> <span class="class">.view</span> {
  <span class="attribute">float</span><span class="pseudo">:left</span>; 
  <span class="attribute">width</span><span class="value">:<span class="number">50</span>%;</span>   <span class="comment">//一和：外层容器为200%，内层为50%，一唱一和正好是原始大小100%。</span>
  <span class="attribute">height</span><span class="value">: auto;</span> 
  <span class="attribute">overflow</span><span class="value">: hidden;</span> 
  <span class="attribute">box-shadow</span><span class="value">:<span class="number">0</span> -<span class="number">12</span>px <span class="number">15</span>px <span class="hexcolor">#999</span>;</span>
  <span class="attribute">min-height</span><span class="value">: <span class="number">400</span>px;</span>
}
</code></pre><p>这是实例演示了如何实现左侧折叠，具体可见demo（还未添加链接），那如何实现左右侧双向折叠呢？设置300%和33.3333333%吗？且听下回分解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近的工作都转移到移动开发中，针对主站www.l99.com开发一套移动端版本，像之前写的《webapp立方没体诞生之初》、《单页应用中页面转场的实现》都是针对此项目。</p>
<p>借此谈谈对原生APP和HTML5 WEBAPP的看法，关于各有千秋、根据项目需求的说法谁都]]>
    </summary>
    
      <category term="collapse html5 bootstrap" scheme="http://yoursite.com/tags/collapse-html5-bootstrap/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[seajs源码解析]]></title>
    <link href="http://yoursite.com/2014/03/17/seajs-source/"/>
    <id>http://yoursite.com/2014/03/17/seajs-source/</id>
    <published>2014-03-17T05:53:07.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>关于seajs的源码解析玉伯自己也只写了两篇<a href="http://chuansongme.com/n/124571" target="_blank" rel="external">http://chuansongme.com/n/124571</a>、<a href="http://chuansongme.com/n/126184" target="_blank" rel="external">http://chuansongme.com/n/126184</a>，去年订阅他的微信号后就已拜读过。讲述了目录结构、大闭包等这些表面的细节，还未真正写到精髓，就没有了。最近项目中应用了seajs，模块化改造也并不复杂，腾出时间专门看看源码。<br>下载个seajs，src目录如下：</p>
<pre><code><span class="comment">src</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">intro</span><span class="string">.</span><span class="comment">js</span>             <span class="literal">-</span><span class="literal">-</span> <span class="comment">全局闭包头部</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">sea</span><span class="string">.</span><span class="comment">js</span>               <span class="literal">-</span><span class="literal">-</span> <span class="comment">基本命名空间</span>

<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">util</span><span class="literal">-</span><span class="comment">lang</span><span class="string">.</span><span class="comment">js</span>         <span class="literal">-</span><span class="literal">-</span> <span class="comment">语言增强</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">util</span><span class="literal">-</span><span class="comment">events</span><span class="string">.</span><span class="comment">js</span>       <span class="literal">-</span><span class="literal">-</span> <span class="comment">简易事件机制</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">util</span><span class="literal">-</span><span class="comment">path</span><span class="string">.</span><span class="comment">js</span>         <span class="literal">-</span><span class="literal">-</span> <span class="comment">路径处理</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">util</span><span class="literal">-</span><span class="comment">request</span><span class="string">.</span><span class="comment">js</span>      <span class="literal">-</span><span class="literal">-</span> <span class="comment">HTTP</span> <span class="comment">请求</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">util</span><span class="literal">-</span><span class="comment">deps</span><span class="string">.</span><span class="comment">js</span>         <span class="literal">-</span><span class="literal">-</span> <span class="comment">依赖提取</span>

<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">module</span><span class="string">.</span><span class="comment">js</span>            <span class="literal">-</span><span class="literal">-</span> <span class="comment">核心代码</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">config</span><span class="string">.</span><span class="comment">js</span>            <span class="literal">-</span><span class="literal">-</span> <span class="comment">配置</span>
<span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">outro</span><span class="string">.</span><span class="comment">js</span>             <span class="literal">-</span><span class="literal">-</span> <span class="comment">全局闭包尾部</span>
</code></pre><p>Dist目录中的sea-debug.js就是上述文件按顺序合并而成，未压缩代码行900+，按模块回顾下吧。</p>
<p>（一）intro.js，只是一个包装而且是个上包装，下包装见outro.js。</p>
<pre><code>(<span class="function"><span class="keyword">function</span><span class="params">(global, undefined)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">global</span>.seajs) {
        <span class="keyword">return</span>
    }
</code></pre><p>jQuery的包装器基本也是这样：</p>
<pre><code>(<span class="keyword">function</span>(window, undefined) {
    var jQuery ＝  <span class="keyword">...</span>
    <span class="keyword">...</span>
    window.jQuery = window.$ = jQuery;
})(window);
</code></pre><p>注意四点：<br>1、自调用匿名函数创建了一个闭包，该作用域中的代码不会破坏和污染全局变量，这是任何一个javascript库所必备的功能。<br>2、jQuery传递是window参数，seajs传递的是global参数，作者说，“在浏览器环境中，global 是 window 对象。在 Node.js 环境中，global 则是 node 环境中的 global 对象。这是一个跨平台的兼容式写法。”<br>3、传入undefined参数是为了确保undefined的值是undefined，避免被低版本浏览器通过window.undefined＝“”这样的赋值语句重写。<br>4、传入window、undefined参数有一个共通原因是可以使其变为局部变量，这样在jQuery代码块中访问它时，不需要将作用域回退到顶层作用域，更快地访问到window对象。同时局部变量可以进行压缩优化，压缩为一个字符，也省不少字节。</p>
<p>（二）sea.js，确保全局环境中只有一个seajs，events、。。。等均保存在data中。</p>
<pre><code><span class="built_in">var</span> seajs <span class="subst">=</span> <span class="built_in">global</span><span class="built_in">.</span>seajs <span class="subst">=</span> {
    <span class="comment">// The current version of Sea.js being used</span>
    version: <span class="string">"2.1.1"</span>
}
<span class="built_in">var</span> <span class="built_in">data</span> <span class="subst">=</span> seajs<span class="built_in">.</span><span class="built_in">data</span> <span class="subst">=</span> {}
</code></pre><p>（三）util-lang.js</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">isType</span><span class="params">(type)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">"[object "</span> + type + <span class="string">"]"</span>
    }
}
<span class="keyword">var</span> isObject = isType(<span class="string">"Object"</span>)
<span class="keyword">var</span> isString = isType(<span class="string">"String"</span>)
<span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || isType(<span class="string">"Array"</span>)
<span class="keyword">var</span> isFunction = isType(<span class="string">"Function"</span>)

<span class="keyword">var</span> _cid = <span class="number">0</span>
<span class="function"><span class="keyword">function</span> <span class="title">cid</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> _cid++
}
</code></pre><p>先举例说明一下如何做类型检测：</p>
<pre><code>var a = <span class="string">"aa"</span><span class="comment">;</span>
console<span class="preprocessor">.log</span>(Object<span class="preprocessor">.prototype</span><span class="preprocessor">.toString</span><span class="preprocessor">.call</span>(a)) //[object String]
var a = <span class="number">123</span><span class="comment">;</span>
console<span class="preprocessor">.log</span>(Object<span class="preprocessor">.prototype</span><span class="preprocessor">.toString</span><span class="preprocessor">.call</span>(a)) //[object Number]
var a = [<span class="string">"aa"</span>]<span class="comment">;</span>
console<span class="preprocessor">.log</span>(Object<span class="preprocessor">.prototype</span><span class="preprocessor">.toString</span><span class="preprocessor">.call</span>(a)) //[object Array]
var a = function(){}<span class="comment">;</span>
console<span class="preprocessor">.log</span>(Object<span class="preprocessor">.prototype</span><span class="preprocessor">.toString</span><span class="preprocessor">.call</span>(a)) //[object Function]
var a = {}<span class="comment">;</span>
console<span class="preprocessor">.log</span>(Object<span class="preprocessor">.prototype</span><span class="preprocessor">.toString</span><span class="preprocessor">.call</span>(a)) //[object Object]
</code></pre><p>原来这么简单，将变量转变成字符串就可以打印出其类型。有没有觉得isType函数有些特别，接受一个type参数，其内部返回一个接受obj参数的匿名函数。为什么不直接定义一个isType函数，传递type、obj两个参数，判断此obj是不是type类型，多好理解。哎，不要乱想，这可是javascript高级技巧——柯里化，柯里化就是把接受多个参数的函数换成接受单一参数的函数，并返回接受余下的参数的新函数的技术。以后写代码也试试这酷炫吊的技巧。</p>
<p>（四）util-events.js,简单事件机制包括绑定、解绑、触发。</p>
<pre><code><span class="keyword">var</span> events = data.events = {}
seajs.on = <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span> {</span>
    <span class="keyword">var</span> <span class="keyword">list</span> = events[name] || (events[name] = []);
    <span class="keyword">list</span>.push(callback);
    <span class="keyword">return</span> seajs;
}
seajs.off = <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span> {</span>}
<span class="keyword">var</span> emit = seajs.emit = <span class="function"><span class="keyword">function</span><span class="params">(name, data)</span> {</span>}
</code></pre><p>1、将事件对象保存到seajs.data.events中；<br>2、每次绑定事件时在seajs.data.events中创建name/callback键值对保存事件的宿主元素和事件处理函数。<br>3、实际应用中主要使用seajs的模块化组织方式，未使用事件绑定功能</p>
<p>（五）util-path.js</p>
<pre><code><span class="keyword">var</span> doc = document
<span class="keyword">var</span> loc = location
<span class="keyword">var</span> cwd = dirname(loc.href)
<span class="keyword">var</span> scripts = doc.getElementsByTagName(<span class="string">"script"</span>)

<span class="comment">// 得到最后一个script标签</span>
<span class="keyword">var</span> loaderScript = doc.getElementById(<span class="string">"seajsnode"</span>) ||
    scripts[scripts.length - <span class="number">1</span>]
<span class="comment">// 最后一个script标签的请求路径，不包括文件名</span>
<span class="keyword">var</span> loaderDir = dirname(getScriptAbsoluteSrc(loaderScript) || cwd)
<span class="comment">// 得到指定标签的全路径</span>
<span class="function"><span class="keyword">function</span> <span class="title">getScriptAbsoluteSrc</span><span class="params">(node)</span> {</span>}
<span class="comment">//提取路径名，如dirname("a/b/c.js?t=123#xx/zz") ==&gt; "a/b/"</span>
<span class="function"><span class="keyword">function</span> <span class="title">dirname</span><span class="params">(path)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">realpath</span><span class="params">(path)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">normalize</span><span class="params">(path)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">parseAlias</span><span class="params">(id)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">parsePaths</span><span class="params">(id)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">parseVars</span><span class="params">(id)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">parseMap</span><span class="params">(uri)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">addBase</span><span class="params">(id, refUri)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">id2Uri</span><span class="params">(id, refUri)</span> {</span>}

<span class="comment">// 对外接口</span>
seajs.resolve = id2Uri
</code></pre><p>(六)util-request.js</p>
<pre><code>//创建<span class="tag">&lt;<span class="title">link</span>&gt;</span>或<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">标签，预加载后插入到页面中。
<span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url, callback, charset)</span> {</span>}
<span class="function"><span class="keyword">function</span> <span class="title">getCurrentScript</span><span class="params">()</span> {</span>}</span>
</code></pre><p>（七）util-deps.js，只有一个函数，用于提取每个模块中require的文件</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">parseDependencies</span><span class="params">(code)</span> {</span>}
</code></pre><p>（八）module.js 模块化的核心策略</p>
<pre><code>seajs.<span class="keyword">use</span> = <span class="function"><span class="keyword">function</span><span class="params">(ids, callback)</span> {</span>
    <span class="comment">//加载config中的预加载项,如jQuery</span>
    Module.preload(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">// ids：依赖模块或是模块本身，第三个参数为模块uri，如http://www.l99.com/_use_4，为什么要拼凑这样一个uri。</span>
        Module.<span class="keyword">use</span>(ids, callback, data.cwd + <span class="string">"_use_"</span> + cid())
    })
    <span class="keyword">return</span> seajs
}
<span class="comment">//获取模块缓存或创建一个新的模块</span>
Module.<span class="keyword">use</span> = <span class="function"><span class="keyword">function</span> <span class="params">(ids, callback, uri)</span> {</span>}
<span class="comment">//加载模块、并设置相应的状态、_waitings、_remain</span>
Module.prototype.load = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
<span class="comment">//得到最终的调用模块的uris</span>
Module.prototype.resolve = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
<span class="comment">//通过id和refUri得到最终的uri，如"dashboard/dashboard_inset_header" + </span>
<span class="comment">//"http://www.l99.com/_use_1"=&gt; //"http://www.l99.com/jscmd/dashboard/dashboard_inset_header.js?v=20140305"</span>
Module.resolve = <span class="function"><span class="keyword">function</span><span class="params">(id, refUri)</span> {</span>}
<span class="comment">//模块的构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Module</span><span class="params">(uri, deps)</span> {</span>
    <span class="keyword">this</span>.uri = uri
    <span class="keyword">this</span>.dependencies = deps || []
    <span class="keyword">this</span>.exports = <span class="literal">null</span>
    <span class="keyword">this</span>.status = <span class="number">0</span>
    <span class="comment">// Who depends on me</span>
    <span class="keyword">this</span>._waitings = {}
    <span class="comment">// The number of unloaded dependencies</span>
    <span class="keyword">this</span>._remain = <span class="number">0</span>
}
</code></pre><p>。。。<br>这个地方还有很多实质内容没有分析，今天先到这，专注不下去了。<br>。。。</p>
<p>（九）outro.js，将this传入闭包体global，在浏览器环境中global 是 window 对象。在 Node.js 环境中global 则是 node 环境中的 global 对象</p>
<pre><code>})(<span class="keyword">this</span>);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>关于seajs的源码解析玉伯自己也只写了两篇<a href="http://chuansongme.com/n/124571" target="_blank" rel="external">http://chuansongme.com/n/124571</a>、<a hre]]>
    </summary>
    
      <category term="seajs源码" scheme="http://yoursite.com/tags/seajs%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动端浏览器下页面制作规范]]></title>
    <link href="http://yoursite.com/2014/03/01/h5-specs/"/>
    <id>http://yoursite.com/2014/03/01/h5-specs/</id>
    <published>2014-03-01T13:47:27.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="要求：">要求：</h2>
<p>兼容各种分辨率下的iPhone和Android设备。</p>
<h2 id="要点：">要点：</h2>
<h3 id="1-_视口viewport">1. 视口viewport</h3>
<p>头部声明与其他页面一致，使用HTML5的写法&lt;!DOCTYPE html&gt;，但需要在head中增加一行：</p>
<pre><code><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span>
</code></pre><p>此处width不要固定宽度，不要后端传值，使用设备宽度即可，并且不允许缩放，以避免页面出现横向滚动条。</p>
<h3 id="2-_尺寸设置">2. 尺寸设置</h3>
<p>一般情况下，设计师提供的是适配iphone尺寸的设计图，通常为640*960，但是iPhone4+在解析网页的时候依旧把自己当作一台横向分辨率为320px的设备，所以针对设计图中标识的横向尺寸按比例缩小，纵向尺寸不变，字体大小减小到2/3，背景图按比例缩小，背景图不能拼接。 尽量不使用固定宽度，使用百分比无法除尽时可以精确到小数点后七位，基本保证无误差。若使用固定宽度，请放在媒体查询中：</p>
<pre><code>@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">320</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">480</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">640</span>px){}
</code></pre><p>注意使用min-width，而不是min -device-width。</p>
<h3 id="3-_从桌面端向下设计VS从移动端向上设计">3. 从桌面端向下设计VS从移动端向上设计</h3>
<p>注意媒体查询的顺序。<br>从桌面端向下设计：</p>
<pre><code>@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">640</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">max</span><span class="attribute">-width</span>: <span class="number">640</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">max</span><span class="attribute">-width</span>: <span class="number">480</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">max</span><span class="attribute">-width</span>: <span class="number">320</span>px){}
</code></pre><p>从移动端向上设计：</p>
<pre><code>@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">320</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">480</span>px){}
@media screen <span class="literal">and</span> (<span class="keyword">min</span><span class="attribute">-width</span>: <span class="number">640</span>px){}
</code></pre><p>推荐使用<strong>从移动端向上设计</strong>，所需的CSS代码更少，代码结构更加清晰。</p>
<h3 id="4-_浏览器模拟测试">4. 浏览器模拟测试</h3>
<p>测试时Chrome的UA配置如下：</p>
<p><img src="/img/h5specs.png" alt="移动APP制作规范"></p>
<h3 id="5-_改变盒模型">5. 改变盒模型</h3>
<p>标准盒模型下width属性只是内容的宽度，在响应式设计中大部分width均为百分比，如果再设置padding和border会导致内容溢出或换行，所以通常在CSS顶级样式中加入：</p>
<pre><code>*, *<span class="pseudo">:before</span>, *<span class="pseudo">:after</span> <span class="rules">{<span class="rule"><span class="attribute">-webkit-box-sizing</span>:<span class="value">border-box</span></span>;<span class="rule"><span class="attribute">-moz-box-sizing</span>:<span class="value">border-box</span></span>;<span class="rule"><span class="attribute">box-sizing</span>:<span class="value">border-box</span></span>;<span class="rule">}</span></span>，
</code></pre><p>使width属性包含padding和border。</p>
<h3 id="6-_手机端测试">6. 手机端测试</h3>
<p>①可将静态页面放置本地目录下:</p>
<pre><code>C:<span class="command">\Program</span> Files (x86)<span class="command">\Apache</span> Software Foundation<span class="command">\Apache</span>2.2<span class="command">\htdocs</span>
</code></pre><p>打开手机浏览器访问：</p>
<pre><code><span class="label">http:</span>//<span class="number">192.168</span><span class="number">.50</span><span class="number">.241</span>/m/cbs-download<span class="preprocessor">.html</span>(本机ip+项目目录)
</code></pre><p>②若访问本地java项目如lifeix-web中的页面，可手动修改手机上的HTTP代理，服务器为本机ip，端口为80，打开手机浏览器通过域名访问。</p>
<p>针对简单的APP下载页面，了解以上内容即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="要求：">要求：</h2>
<p>兼容各种分辨率下的iPhone和Android设备。</p>
<h2 id="要点：">要点：</h2>
<h3 id="1-_视口viewport">1. 视口viewport</h3>
<p>头部声明与其他页面一致，使用HTM]]>
    </summary>
    
      <category term="h5 webapp iPhone Android viewport media query" scheme="http://yoursite.com/tags/h5-webapp-iPhone-Android-viewport-media-query/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[老调重弹：那些年一遍又一遍领悟过的原型链]]></title>
    <link href="http://yoursite.com/2014/02/12/js-prototype/"/>
    <id>http://yoursite.com/2014/02/12/js-prototype/</id>
    <published>2014-02-12T07:22:48.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>一过年吃了许多肉，见了许多人，又思考了许多人生大事，中了年后综合症的招，唯恐脑子不再灵光，荒废专业。特意把基础知识再梳理一下：</p>
<h3 id="一、简单原型链：构造函数、原型、实例">一、简单原型链：构造函数、原型、实例</h3>
<p><img src="/img/prototype1.png" alt="简单原型链"><br>这是Nicholas C. Zakas的《Javascript高级程序设计》P120的截图。有一个前端朋友说，他曾经怎么都不理解原型链直到看到此书此章节才如醍醐灌顶。我想，看一遍就领悟恐怕也是神人了。</p>
<p>这张图的重点总结如下：</p>
<ol>
<li>只要创建了一个新函数，就为该函数创建一个prototype属性</li>
<li>Prototype属性会自动获得一个constructor属性。</li>
<li>Constructor属性包含快一个指向prototype所在函数的指针。</li>
<li>可为原型增加其他属性和方法</li>
<li>创建新实例，其内部包含一个名为protyo (内部属性)的指针指向其构造函数的原型属性。</li>
</ol>
<p>此外，还有两个特别的方法用来确定其内部关系：</p>
<ol>
<li>实例person1、person2与Person原型之间的关系<pre><code> <span class="function">alert(Person.prototype.<span class="function">isPrototypeOf(person1)</span>)</span>;<span class="comment">//true</span>
 <span class="function">alert(Person.prototype.<span class="function">isPrototypeOf(person2)</span>)</span>;<span class="comment">//true来自实例本身</span>
</code></pre></li>
<li>我们知道，如果要读取person1的某个属性，搜索首先从实例本身开始，如果没有会继续搜索原型对象。那么如何知道搜索到的属性是来自实例本身还是原型？<pre><code> <span class="function">alert(person1.<span class="function">hasOwnProperty(“name”)</span>)</span> <span class="comment">//true来自实例本身</span>
</code></pre></li>
</ol>
<p><strong>最后，原型对象有一个问题。</strong><br>原型中所有属性是被很多实例共享的，通过在实例上添加一个同名属性可以隐藏原型中的对应属性。但是如果这个属性是引用属性就有麻烦了。举例如下：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span>{</span>   }
Person.prototype = {
    constructor:Person,
    name:<span class="string">"Nicholas"</span>,
    age:<span class="number">29</span>,
    friends:[<span class="string">"shelby"</span>,<span class="string">"Court"</span>],
    sayName:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>....}
}
<span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();
<span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();
person1.friends.push(<span class="string">"Van"</span>);
alert(person1.friends);<span class="comment">//["shelby","Court","Van"]</span>
alert(person2.friends);<span class="comment">//["shelby","Court","Van"]</span>
alert(person1.friends===person2.friends); <span class="comment">//true</span>
</code></pre><p>原因是friends数组存在于Person.prototype中，不是在person1中。如果是简单属性赋值比如person1.age = 30并不影响Person.prototype.age=29。</p>
<h3 id="二、继承原型链：">二、继承原型链：</h3>
<p><img src="/img/prototype2.png" alt="简单原型链"><br>提示：所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针__proto指向Object.prototype。继承Object这部分未在图中体现。<br>下面我们研究继承是怎么实现的？</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span>{</span>
    <span class="keyword">this</span>.species = “动物”
}
Animal.prototype = {
    say: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        alert(“I am a ”+ <span class="keyword">this</span>.species +”,my name <span class="keyword">is</span> XXX”);
}
}
<span class="function"><span class="keyword">function</span> <span class="title">cat</span><span class="params">(name,color)</span>{</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.color = color;
}
</code></pre><p>如何使”猫”继承“动物”？继承分两部分，分别是构造函数继承和原型继承。构造函数继承实现了对实例属性的继承，原型实现对原型属性和方法的继承。</p>
<h4 id="1-_构造函数继承">1. 构造函数继承</h4>
<pre><code>    <span class="function"><span class="keyword">function</span> <span class="title">cat</span> <span class="params">(name, color)</span>{</span>
        Animal.call(<span class="keyword">this</span>);
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.color = color;
    }
</code></pre><h4 id="2-_原型继承">2. 原型继承</h4>
<pre><code>    Cat.prototype = <span class="keyword">new</span> Animal();
    Cat.prototype.<span class="keyword">constructor</span> = Cat;
    <span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(“大毛”，“黄色”);
    alert（cat1.species）； <span class="comment">//动物</span>
</code></pre><p>此时，原型继承同时继承了构造函数中不变的属性species。事实上，不变的属性应该写入原型，作为原型属性。</p>
<h4 id="3-_直接原型继承">3. 直接原型继承</h4>
<p>为什么要将Animal的实例作为Cat的原型呢？如果将Animal的原型赋值给Cat的原型如何呢？<br>改写Animal对象：</p>
<pre><code>    function Animal(){}
    Animal<span class="preprocessor">.prototype</span><span class="preprocessor">.species</span> = “动物”<span class="comment">;</span>
    Cat<span class="preprocessor">.prototype</span> = Animal<span class="preprocessor">.prototype</span><span class="comment">;</span>
    Cat<span class="preprocessor">.prototype</span><span class="preprocessor">.constructor</span> = Cat<span class="comment">;</span>
    var cat1 = new Cat(“大毛”，“黄色”)<span class="comment">;</span>
    alert（cat1<span class="preprocessor">.species</span>）； //动物
</code></pre><p>优点：不用执行和建立Animal实例，省内存<br>缺点：cat.prototype和animal.prototype都指向同一对象，对cat.prototype的修改都会反映到animal.prototype上。</p>
<h4 id="4-_对上个方案的改进——利用空对象作中介">4. 对上个方案的改进——利用空对象作中介</h4>
<pre><code>    <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(subclass, superclass)</span> {</span>
            <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
            F.prototype = superclass.prototype;
            subclass.prototype = <span class="keyword">new</span> F();
            subclass.prototype.constructor = subclass;
    }
</code></pre><h4 id="5-_拷贝继承">5. 拷贝继承</h4>
<p>引颖同学曾大力推荐的自创类库中使用的是拷贝继承，将父对象的所有属性和方法拷贝进子对象。</p>
<pre><code>    <span class="function"><span class="keyword">function</span> <span class="title">extend</span> （<span class="title">subclass</span>, <span class="title">superclass</span>）{</span>
            <span class="keyword">Var</span> p = superclass.prototype;
            <span class="keyword">Var</span> c = subclass.prototype;
            <span class="keyword">for</span>(<span class="keyword">var</span> i in p){
                C[i] = p[i]
            }
    }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>一过年吃了许多肉，见了许多人，又思考了许多人生大事，中了年后综合症的招，唯恐脑子不再灵光，荒废专业。特意把基础知识再梳理一下：</p>
<h3 id="一、简单原型链：构造函数、原型、实例">一、简单原型链：构造函数、原型、实例</h3>
<p><img src="/img]]>
    </summary>
    
      <category term="原型链 继承" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单页应用中页面转场的实现]]></title>
    <link href="http://yoursite.com/2014/02/06/h5-pagetransition/"/>
    <id>http://yoursite.com/2014/02/06/h5-pagetransition/</id>
    <published>2014-02-06T07:42:46.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>在上上篇文章《webapp立方没体诞生之初》中提到，移动框架只使用了Boostrap，但后来迫于页面转场效果，自定义build了jquery mobile的Animated page Transitions部分功能，60多k的代码也让人唏嘘。于是，剖析源码，尝试简化。</p>
<p><img src="/img/pageTransition1.png" alt="页面转场"></p>
<p>在看源码之前思考一下自己如何实现：</p>
<ol>
<li>页面切换效果：如何让上一个页面移开，让下个页面进入</li>
<li>当上个页面的滚动条向下滚动一段距离后，如何平滑地移动到下个页面的顶部。</li>
<li>浏览器中如何回退？</li>
</ol>
<h3 id="一、_页面初始化和事件绑定">一、 页面初始化和事件绑定</h3>
<p><strong>HTML：</strong></p>
<pre><code>    <span class="subst">&lt;</span>div <span class="built_in">data</span><span class="attribute">-role</span><span class="subst">=</span><span class="string">"page"</span> id<span class="subst">=</span><span class="string">"page_content"</span> class<span class="subst">=</span><span class="string">""</span><span class="subst">&gt;</span>
        <span class="attribute">...</span><span class="attribute">...</span>
        <span class="subst">&lt;</span>a class<span class="subst">=</span><span class="string">"p_notes left"</span> href<span class="subst">=</span><span class="string">"#page_notes"</span> <span class="built_in">data</span><span class="attribute">-transition</span><span class="subst">=</span><span class="string">"slide"</span><span class="subst">&gt;</span><span class="number">8</span>条回应<span class="subst">&lt;</span>/a<span class="subst">&gt;</span>
        <span class="attribute">...</span><span class="attribute">...</span>
    <span class="subst">&lt;</span>/div<span class="subst">&gt;</span>
    <span class="subst">&lt;</span>div <span class="built_in">data</span><span class="attribute">-role</span><span class="subst">=</span><span class="string">"page"</span> id<span class="subst">=</span><span class="string">"page_notes"</span> class<span class="subst">=</span><span class="string">"lst_notescontainer"</span><span class="subst">&gt;</span>
        <span class="attribute">...</span><span class="attribute">...</span>
    <span class="subst">&lt;</span>/div<span class="subst">&gt;</span>
</code></pre><p><strong>Jquery.mobile.custom.js：</strong></p>
<p><img src="/img/pageTransition2.png" alt="页面转场"></p>
<p>页面初始化中主要做了以下事情，暂不涉及hash存储：</p>
<ol>
<li>记录所有pages对象(含有data-role=”page”的DOM)；</li>
<li>将第一个page设为当前page；</li>
<li>让当前page入场。</li>
</ol>
<p>代码简化如下：</p>
<pre><code><span class="keyword">var</span> PageTransition = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> <span class="variable">$pages</span>; <span class="comment">//记录所有page对象</span>
    <span class="keyword">var</span> pageArray = []; <span class="comment">//记录所有pageId</span>
    <span class="keyword">return</span> {
        init: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="variable">$pages</span> = $(<span class="string">"*[data-role='page']"</span>);
            $(<span class="string">"body"</span>).addClass(<span class="string">"ui-mobile"</span>);
            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable">$pages</span>.length; i++){
                pageArray.push(<span class="variable">$pages</span>.eq(i).attr(<span class="string">"id"</span>));
                <span class="comment">//标记首个page为当前活动page</span>
                <span class="keyword">if</span>(i == <span class="number">0</span>){
                    <span class="variable">$pages</span>.eq(i).addClass(<span class="string">"ui-page-active"</span>);
                }
            }
        }
}
}());
</code></pre><p>页面初始化完成后，向锚点绑定事件来完成页面转场：<br><img src="/img/pageTransition3.png" alt="页面转场"><br>那这个神秘的changePage方法是如何实现的?</p>
<h3 id="二、页面转场的外衣">二、页面转场的外衣</h3>
<p>辗转经历各种call之后进入change方法，别以为这就登堂入室了，还要一层层剥开迷雾~~<br><img src="/img/pageTransition4.png" alt="页面转场"><br>对_cssTransition望文生义，难道是CSS3的transition实现的？那岂不是对上下页add或remove 相应动画的class即可。耶！确实如此，不过还得耐得性子读一读这像老太太裹脚布一样的代码~~~</p>
<h3 id="三、页面转场的核心代码">三、页面转场的核心代码</h3>
<p><img src="/img/pageTransition5.png" alt="页面转场"></p>
<p><strong>CSS:</strong></p>
<pre><code><span class="at_rule">@<span class="keyword">-webkit-keyframes</span> slideinfromright </span>{
    <span class="tag">from</span> <span class="rules">{<span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate3d(<span class="number">100</span>%, <span class="number">0</span>, <span class="number">0</span>)</span></span></span>;<span class="rule">}</span></span>
    <span class="tag">to</span> <span class="rules">{<span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span></span>;<span class="rule">}</span></span>
}

<span class="at_rule">@<span class="keyword">-webkit-keyframes</span> slideouttoleft </span>{
    <span class="tag">from</span> <span class="rules">{<span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span></span>;<span class="rule">}</span></span>
    <span class="tag">to</span> <span class="rules">{<span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate3d(-<span class="number">100</span>%, <span class="number">0</span>, <span class="number">0</span>)</span></span></span>;<span class="rule">}</span></span>
}
<span class="class">.slide</span><span class="class">.out</span>,<span class="class">.slide</span><span class="class">.in</span> <span class="rules">{
    <span class="rule"><span class="attribute">-webkit-animation-timing-function</span>:<span class="value"> ease-out</span></span>;
    <span class="rule"><span class="attribute">-webkit-animation-duration</span>:<span class="value"> <span class="number">350</span>ms</span></span>;
    <span class="rule"><span class="attribute">-moz-animation-timing-function</span>:<span class="value"> ease-out</span></span>;
    <span class="rule"><span class="attribute">-moz-animation-duration</span>:<span class="value"> <span class="number">350</span>ms</span></span>;
    <span class="rule"><span class="attribute">animation-timing-function</span>:<span class="value"> ease-out</span></span>;
    <span class="rule"><span class="attribute">animation-duration</span>:<span class="value"> <span class="number">350</span>ms</span></span>;
<span class="rule">}</span></span>
<span class="class">.slide</span><span class="class">.in</span> <span class="rules">{
    <span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span></span>;
    <span class="rule"><span class="attribute">-webkit-animation-name</span>:<span class="value"> slideinfromright</span></span>;
    <span class="rule"><span class="attribute">-moz-transform</span>:<span class="value"> <span class="function">translateX(<span class="number">0</span>)</span></span></span>;
    <span class="rule"><span class="attribute">-moz-animation-name</span>:<span class="value"> slideinfromright</span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateX(<span class="number">0</span>)</span></span></span>;
    <span class="rule"><span class="attribute">animation-name</span>:<span class="value"> slideinfromright</span></span>;
<span class="rule">}</span></span>
<span class="class">.slide</span><span class="class">.out</span> <span class="rules">{
    <span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate3d(-<span class="number">100</span>%, <span class="number">0</span>, <span class="number">0</span>)</span></span></span>;
    <span class="rule"><span class="attribute">-webkit-animation-name</span>:<span class="value"> slideouttoleft</span></span>;
    <span class="rule"><span class="attribute">-moz-transform</span>:<span class="value"> <span class="function">translateX(-<span class="number">100</span>%)</span></span></span>;
    <span class="rule"><span class="attribute">-moz-animation-name</span>:<span class="value"> slideouttoleft</span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateX(-<span class="number">100</span>%)</span></span></span>;
    <span class="rule"><span class="attribute">animation-name</span>:<span class="value"> slideouttoleft</span></span>;
<span class="rule">}</span></span>
<span class="class">.ui-page-pre-in</span> <span class="rules">{
    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.ui-page-active</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> visible</span></span>;
    <span class="rule"><span class="attribute">overflow-x</span>:<span class="value"> hidden</span></span>;
<span class="rule">}</span></span>
</code></pre><p>不得不用文字描述一下这个过程，尽管繁琐得要命。<br><img src="/img/pageTransition6.png" alt="页面转场"></p>
<p>上图为控制台输出，翻译后意思是：<br>1：下页藏到最后面（z-index=-10）<br>2：下页显示又隐藏（display:block &amp;&amp; opacity=0）<br>3：下页不用藏到最后面了，原来在哪就在哪<br>4：下页显示，开始入场<br>5：当前页离场<br>6：动画完成后当前页成为了上页隐藏、并移除动画样式<br>7：动画完成后下页成为了当前页移除动画样式。<br>真是搞不懂1、2、3在墨迹啥。</p>
<p>自行实现后代码如下：<br><img src="/img/pageTransition7.png" alt="页面转场"><br>文章开头提出了三个问题，至此才说清楚一个。真是想得太远，走得太慢啦。Zepto.js号称是jquery mobile的简化版，有时间再看看它是怎么实现的吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上上篇文章《webapp立方没体诞生之初》中提到，移动框架只使用了Boostrap，但后来迫于页面转场效果，自定义build了jquery mobile的Animated page Transitions部分功能，60多k的代码也让人唏嘘。于是，剖析源码，尝试简化。</p]]>
    </summary>
    
      <category term="jquery mobile SAP 转场动画" scheme="http://yoursite.com/tags/jquery-mobile-SAP-%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[团队成长记——《在你身边为你设计》读后感]]></title>
    <link href="http://yoursite.com/2014/01/20/read-team/"/>
    <id>http://yoursite.com/2014/01/20/read-team/</id>
    <published>2014-01-20T08:11:26.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>最近在看一本书《在你身边为你设计》，出自腾讯CDC团队（用户研究与体验设计中心）的结集文章。看书如见人，通过不同文章的观点和看问题的角度对各个作者的专业方向和管理层级也略知一二。个人更喜欢唐沐的文章，他是腾讯CDC团队的创始人，给大家缕一下这个团队从无到有的过程。</p>
<h3 id="1-_2003年4月入职UI设计组">1. 2003年4月入职UI设计组</h3>
<p>唐沐入职腾讯可以说是天时地利，当时QQ作为腾讯唯一的重要产品刚刚完成了原始积累——用户数达到了一个量级，用户对产品的需求也刚刚从满足基本功能转变到追求更好的UI体验。其次，唐沐在大学辅修过工业设计，重要的是在金山练就软件产品UI设计的思路和技能，这些成为在腾讯开展用户体验设计的基石。</p>
<p>在刚入职的几个月里，他被同事们习以为常地称为“美工”，在非常有限的资源下，不分昼夜地完成了QQ2003、QQGame、TM1.0等设计项目。那个过程中赢得的客户关系和上级信任，是CDC最原始的资本积累。</p>
<h3 id="2-_2003年5月第一名交互设计师">2. 2003年5月第一名交互设计师</h3>
<p>当时交互设计还不是一个被广泛理解和接受的词，交互设计所负责的工作基本是被产品经理和GUI设计师填补了。于是按照GUI设计师招聘了第一位工业设计背景的专职的交互设计师。一开始也并不被认可，在一次传统模式还是创新模式的拉锯战中，提供了兼容两种模式，可自由切换的方案，才达到产品经理和用户双赢的局面。这种方案一直持续到2005年，才完全切换到新模式中。</p>
<h3 id="3_2005年第一个用户体验室">3 2005年第一个用户体验室</h3>
<p>UI设计组已经有20余人，交互设计师的招聘依然不理想，但内部慢慢形成了培训供血机制，形成了先交互再视觉的设计流程。同时，遇到了一个新问题：交互设计师和产品经理在用户体验的判断上有差异，主观判断较多，莫衷一是。于是，谁来判断设计的好坏？在资源有限的情况下，团队建设了第一间用户体验观察室，非常简陋，只有一些简单的拾音设备和单面镜。至今，CDC拥有专职的用户研究工程师超过40人，近10间专业的用户体验室分布在全国，用户研究方法也从单一的实验室观察扩展到眼动研究、焦点访谈、深度访谈、问卷调查、田野研究等。</p>
<p>事实上，如果没有第一间用户体验室，用户研究的工作也可以进行，但是这个房间是一个信号，一种态度，需要告诉客户，用户研究是一门专门的学科，可以帮助产品决策。在当时中国互联网和腾讯的大环境里，这确实是一个需要创意和魄力的解决方案。</p>
<h3 id="4_2006年5月CDC正式成立">4 2006年5月CDC正式成立</h3>
<p>团队由一个设计中心正式挂牌成立，升级为“公司级”的设计中心，一个独立预算的单位。内部包括三个主要角色：交互设计、视觉设计、用户研究。随着人员的扩充，人事和团队管理都遇到很多新的问题。为了保证对团队文化、专业积累有很好的传承，管理干部基本都从团队中产生，很少外部引进。同时，专业骨干在管理过程中不能忽略自身专业成长和业绩。</p>
<h3 id="5-_2008年设计研发组成立">5. 2008年设计研发组成立</h3>
<p>CDC团队规模达到了80多人，项目达到50多，内部客户几乎拓展到了整个腾讯公司。但是开发团队会将功能开发优先于界面开发，并且认为界面开发没有太多值得研究的东西，造成了界面开发的边缘化，也制约着设计能否在产品中得以完美呈现。解决方案就是为设计团队配备开发工程师，招聘开发与设计的“边缘人”（前端开发工程师）并不容易，于是从开发团队的毕业生中“偷”了两个对设计和用研数据感兴趣的候选人。</p>
<h3 id="6-_2011年专业线向项目线变革">6. 2011年专业线向项目线变革</h3>
<p>CDC团队规模达到200多人，在北京、上海、成都都有了自己的分部。团队人数的快速增加很大程度归因于项目的持续增长，以跟上公司快速发展的步伐。数十人和数百人在团队管理上是不同的境界，CDC一直是以专业线划分团队的，在专业建设和质量把控上很好，设计师的专业成长路径清晰，培训体制成熟，但是项目压力传导不到位，效率低下。所以整个部门的组织架构需要艰难地从专业线朝项目线调整。变革需要付出代价，有些设计师非常不适应。同一阶段，人才争夺激烈、猎聘挖角接连不断，2011年整年损失了相当一部分骨干。这也促成了CDC更大胆更快递进行变革。</p>
<h3 id="7-_作者展望">7. 作者展望</h3>
<p>不希望CDC继续变大，甚而希望适当缩小，这几年的发展中我们深深认识到：<br>a)一个设计团队的成功，并不在于TA有多大，而在于TA做过多少成功项目；<br>b)只有聚焦，才有精品；<br>c)资源永远都是有限的，用有限的资源把事情做好，才有机会拥有更多的资源把事情做好；<br>d)细致分工在一些阶段是良药，过了这些阶段就是毒药。</p>
<p>很抱歉，我大段摘抄又小小概述了原文内容。在这个优秀团队的十年成长史中，充满了行业的缩影，团队的工作风格也让人艳羡。“踏踏实实，先把眼前的事情做好。现有资源下做出超预期的事，拿到更多资源之后循环往复。”每一次挑战的顺利渡过都是这个信条的实践。作者没有把这篇文章写成励志史，过于强调个人素质和努力，只是把经验和教训分享出来，读起来自然舒服，又让人敬佩。</p>
<p><strong>我觉得作者做事上有两种“道”:一种是水到渠成，比如他入职腾讯时机可谓是“恰到好处”，具备了成功的可能性。再比如他谈到周边准备度，就是说构成你周边环境的人、时间、资源是否达到了你可以成事的程度。往往一个人想做成一件事，就好像堆石头上山，费劲力气推到山顶去，倘若山顶的四周空空如也，石头无所立足，会马上滚回原点，所有努力白费。真正需要做到的，是随机应变，在有限的条件下踏踏实实把事情做好。周边准备度，是可以随着不断把事情做成而提升的。另一种是开创精神，比如如何招聘史上第一位交互设计师、如何给设计团队配备界面开发工程师，如何成立第一间用户观察室，如何不同于其他团队拥有向最高决策层汇报的权利，用作者自己的话说，“这是团队特定的成长经历和我们经过长期的努力争取到的一种权利”。</strong></p>
<p>目前，唐沐已与2013年5月离职腾讯加入小米，又回到了雷军的怀抱。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看一本书《在你身边为你设计》，出自腾讯CDC团队（用户研究与体验设计中心）的结集文章。看书如见人，通过不同文章的观点和看问题的角度对各个作者的专业方向和管理层级也略知一二。个人更喜欢唐沐的文章，他是腾讯CDC团队的创始人，给大家缕一下这个团队从无到有的过程。</p>
]]>
    </summary>
    
      <category term="在你身边为你设计 唐沐 腾讯" scheme="http://yoursite.com/tags/%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%B8%BA%E4%BD%A0%E8%AE%BE%E8%AE%A1-%E5%94%90%E6%B2%90-%E8%85%BE%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[webapp立方没体诞生之初]]></title>
    <link href="http://yoursite.com/2014/01/08/h5-webapp/"/>
    <id>http://yoursite.com/2014/01/08/h5-webapp/</id>
    <published>2014-01-08T08:18:31.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>随着移动设备特别是智能手机的普及，移动应用的市场越发火爆。原生应用以优秀的离线能力、客户端能力（能方便使用手机上的各种终端能力）、高性能、流畅的动画效果大受用户青睐，但仍存在多个系统上的开发、发布、下载使用等瓶颈。而webapp正是为了解决这些不足，同时满足长尾用户的需求。</p>
<h3 id="1-_准备工作">1. 准备工作</h3>
<p>在试水立方没体之前，拿登录页面做过实验，在基本不改变设计的情况对web页面结构进行简化或隐藏，注意是对同一套代码进行响应式实现，可想而知，这种方式的结果就如同粗放地减枝，效果不好。当时一直犹豫不决地是使用响应式（兼容各种PC、移动设备）还是为移动设备专门做一套页面结构？显然，前者是完美的，后者是现实的。接着研究了知乎和qzone，恰巧知乎使用的是“完美”方案，而qq空间使用的“现实”方案。鉴于立方网复杂的页面设计，选择后者更明智。</p>
<h3 id="2-_选择移动框架">2. 选择移动框架</h3>
<p>网上关于各种移动框架比较的资料很多，sencha Touch 和jquery mobile的大哥地位是毋庸置疑的、但是动辄就是一二百KB让人心中滴血啊，所以更倾向于小巧的框架，方便整合和自开发。Bootstrap号称风格简洁清新，是CSS框架+jquery组件的组合，正好适合我们以jquery为基础的框架结构。</p>
<p>立方没体的瀑布式布局使用的是我们自开发插件，不需要依赖于其他框架。只借用Bootstrap的CSS部分即可。后来确实遇到了需要借助其他框架的情况，比如单页技术中的页面切换效果。考虑到时间和技术细节，直接使用了jquery mobile的Animated page Transitions部分功能。</p>
<p>立方没体的webapp v1.0版本已经上线，大体思路是借助各种移动框架（基本都支持自定义build）的特定功能整合成适合我们的方案，如果时间充足的话，也可以将用到的功能再简化、抽离或重写，形成立方的前端框架。</p>
<h3 id="3-_一半开发、一半设计">3. 一半开发、一半设计</h3>
<p>不知是不幸还是万幸——没有设计师参与。只是在参考了pinterest、百度、网易，再融入立方设计后，尝试了N套样式，纠结得四分五裂，待某人一拍板“不需要，就这样”之后，才如释重负。立方没体的定位是自媒体，为了保证手机端良好的阅读体验，在字体、字号、间距、行距、圆角、阴影等方面的比较推敲花了很多功夫。</p>
<h3 id="4-_一半开发、一半数据">4. 一半开发、一半数据</h3>
<p>用户的访问量是项目持续推进的一大动力，常常在迭代上线之初微涨，过几天又稳落，促使我不停地考虑如何推进，如何保持增势，这种数据导向的优势就是让人自High，自娱自乐。截止目前，移动端访问量占桌面+移动总访问量的19.2%，而20天前是12.01%（其实，桌面web前端也是我负责的，这不是用我的矛戳我的盾嘛）。当然这个数据不可避免得搭乘了移动访问普遍增速的大船。</p>
<p>至此没有涉及具体代码实现，也没有发现什么技术难点。重要还是设计、创意、体验、细节。<br>附：手机浏览器访问<a href="http://www.l99.com/media" target="_blank" rel="external">www.l99.com/media</a>,欢迎吐槽</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着移动设备特别是智能手机的普及，移动应用的市场越发火爆。原生应用以优秀的离线能力、客户端能力（能方便使用手机上的各种终端能力）、高性能、流畅的动画效果大受用户青睐，但仍存在多个系统上的开发、发布、下载使用等瓶颈。而webapp正是为了解决这些不足，同时满足长尾用户的需求。]]>
    </summary>
    
      <category term="响应式 webapp" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F-webapp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[献给2014年的第一场雪]]></title>
    <link href="http://yoursite.com/2013/12/12/js-snowflake/"/>
    <id>http://yoursite.com/2013/12/12/js-snowflake/</id>
    <published>2013-12-12T08:22:52.000Z</published>
    <updated>2015-02-13T06:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>当我查找MVC、MVP、MVVM这些设计模式相关资料时，发现了这个背景效果——飘雪——做得还不错的网站，<a href="http://nirajrules.wordpress.com/2009/07/18/mvc-vs-mvp-vs-mvvm/" target="_blank" rel="external">http://nirajrules.wordpress.com/2009/07/18/mvc-vs-mvp-vs-mvvm/</a>，如果你不能打开链接，就悲剧了，“墙”里难见“墙”外花。于是，从该站点剥离出纯粹实现此动画的代码，制作demo如链接（忙啊！！还没传上去）。</p>
<p>我们会发现一些细节，鼠标移动的轨迹控制了风向和风速，从而控制雪花的方向和速度；当前tab不是活动tab时动画停止，避免过度绘制。说说你实现该效果的思路，或是关键词。定时器？运动轨迹？边际检测？我们先按照自己的思路一步一步走，再结合它的代码修正。</p>
<ol>
<li>制造雪花</li>
<li>执行定时器</li>
</ol>
<p>哦，就这样？好像也很简单~</p>
<h3 id="1、采用何种模式？">1、采用何种模式？</h3>
<p>前提是基于原生javascript来考虑，不要受jquery的影响。首先这里不涉及继承，这就简单很多。javascript中最基本又最有用的模式就是单体，用来划分命名空间并将一批相关属性和方法组织在一起，同时也对外提供了一个访问内部属性和方法的访问点。为了避免被外界访问，将单例的“值部分”闭包起来，在内部返回当前活动对象（绑定到this上的属性和方法仍然可以被外部访问）。好，外壳做好了~</p>
<pre><code>var snowStorm = (<span class="keyword">function</span>(window, document) {
   <span class="keyword">...</span>
   <span class="keyword">return</span> this;
}(window, document));;
</code></pre><h3 id="2、制造雪花">2、制造雪花</h3>
<p>如何构造雪花，它的构造函数需要哪些属性？位置坐标必须有，用来记录和控制轨迹？关联DOM对象必须有， 方便设置view相关属性? 它需要哪些方法呢？setPosition（设置位置）？setVelocities（设置速度）？move（移动的入口函数）？根据效果需要可能还需要melt（融化）、stick（堆成雪堆）等。多个雪花实例是随机生成的，运动也互不影响，不必有共享的属性和方法，所以不考虑原型。抽取出的代码结构如下：</p>
<pre><code><span class="keyword">this</span>.SnowFlake = <span class="function"><span class="keyword">function</span><span class="params">(type,x,y)</span> {</span>
    <span class="keyword">var</span> s = <span class="keyword">this</span>;
    <span class="keyword">this</span>.type = type;
    <span class="keyword">this</span>.x = x||<span class="built_in">parseInt</span>(rnd(screenX-<span class="number">20</span>),<span class="number">10</span>);
    <span class="keyword">this</span>.y = (!<span class="built_in">isNaN</span>(y)?y:-rnd(screenY)-<span class="number">12</span>);
    <span class="keyword">this</span>.vX = <span class="literal">null</span>;
    <span class="keyword">this</span>.vY = <span class="literal">null</span>;
    <span class="keyword">this</span>.active = <span class="number">1</span>;
    <span class="keyword">this</span>.fontSize = (<span class="number">10</span>+(<span class="keyword">this</span>.type/<span class="number">5</span>)*<span class="number">10</span>);
    <span class="keyword">this</span>.o = document.createElement(<span class="string">'div'</span>);
    <span class="keyword">this</span>.o.innerHTML = storm.snowCharacter;
    <span class="keyword">this</span>.o.style.color = storm.snowColor;
    <span class="keyword">this</span>.o.style.position = (fixedForEverything?<span class="string">'fixed'</span>:<span class="string">'absolute'</span>);
    <span class="keyword">this</span>.o.style.width = storm.flakeWidth+<span class="string">'px'</span>;
    <span class="keyword">this</span>.o.style.height = storm.flakeHeight+<span class="string">'px'</span>;
    <span class="keyword">this</span>.o.style.fontFamily = <span class="string">'arial,verdana'</span>;
    <span class="keyword">this</span>.o.style.cursor = <span class="string">'default'</span>;
    <span class="keyword">this</span>.o.style.overflow = <span class="string">'hidden'</span>;
    <span class="keyword">this</span>.o.style.fontWeight = <span class="string">'normal'</span>;
    <span class="keyword">this</span>.o.style.zIndex = storm.zIndex;
    docFrag.appendChild(<span class="keyword">this</span>.o);

    <span class="keyword">this</span>.refresh = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      ......
      storm.setXY(s.o, s.x, s.y);
    };

    <span class="keyword">this</span>.vCheck = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (s.vX&gt;=<span class="number">0</span> &amp;&amp; s.vX&lt;<span class="number">0.2</span>) {
        s.vX = <span class="number">0.2</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (s.vX&lt;<span class="number">0</span> &amp;&amp; s.vX&gt;-<span class="number">0.2</span>) {
        s.vX = -<span class="number">0.2</span>;
      }
      <span class="keyword">if</span> (s.vY&gt;=<span class="number">0</span> &amp;&amp; s.vY&lt;<span class="number">0.2</span>) {
        s.vY = <span class="number">0.2</span>;
      }
    };

    <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        ...
    };

    <span class="keyword">this</span>.setVelocities = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      s.vX = vRndX+rnd(storm.vMaxX*<span class="number">0.12</span>,<span class="number">0.1</span>);
      s.vY = vRndY+rnd(storm.vMaxY*<span class="number">0.12</span>,<span class="number">0.1</span>);
    };

    <span class="keyword">this</span>.setOpacity = <span class="function"><span class="keyword">function</span><span class="params">(o,opacity)</span> {</span>
      <span class="keyword">if</span> (!opacitySupported) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
      o.style.opacity = opacity;
    };

    <span class="keyword">this</span>.melt = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (!storm.useMeltEffect || !s.melting) {
        s.recycle();
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (s.meltFrame &lt; s.meltFrameCount) {
          s.setOpacity(s.o,s.meltFrames[s.meltFrame]);
          s.o.style.fontSize = s.fontSize-(s.fontSize*(s.meltFrame/s.meltFrameCount))+<span class="string">'px'</span>;
          s.o.style.lineHeight = storm.flakeHeight+<span class="number">2</span>+(storm.flakeHeight*<span class="number">0.75</span>*(s.meltFrame/s.meltFrameCount))+<span class="string">'px'</span>;
          s.meltFrame++;
        } <span class="keyword">else</span> {
          s.recycle();
        }
      }
};
</code></pre><p>构造函数完成，可以制造雪花，插入到页面了。</p>
<pre><code>this<span class="preprocessor">.createSnow</span> = function(limit,allowInactive) {
    var i<span class="comment">;</span>
    for (i=<span class="number">0</span><span class="comment">; i&lt;limit; i++) {</span>
      storm<span class="preprocessor">.flakes</span>[storm<span class="preprocessor">.flakes</span><span class="preprocessor">.length</span>] = new storm<span class="preprocessor">.SnowFlake</span>(parseInt(rnd(flakeTypes),<span class="number">10</span>))<span class="comment">;</span>
      if (allowInactive || i&gt;storm<span class="preprocessor">.flakesMaxActive</span>) {
        storm<span class="preprocessor">.flakes</span>[storm<span class="preprocessor">.flakes</span><span class="preprocessor">.length</span>-<span class="number">1</span>]<span class="preprocessor">.active</span> = -<span class="number">1</span><span class="comment">;</span>
      }
    }
    storm<span class="preprocessor">.targetElement</span><span class="preprocessor">.appendChild</span>(docFrag)<span class="comment">;</span>
}<span class="comment">;</span>
</code></pre><p>关于move方法的实现，也就是移动轨迹相关的细节，我曾一度想了解动画原理，仔细分析下这个方法：</p>
<pre><code><span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">// rnd: 返回[param2,param1)之间的随机数</span>
    <span class="comment">// plusMinus: 以相同概率返回±param</span>
    <span class="comment">// storm.vMaxX=2.5：水平方向最大速度</span>
    <span class="comment">// 水平风速vRndX = plusMinus(rnd(storm.vMaxX,0.2)); --from randomizeWind（）</span>
    <span class="comment">// vRndX∈±[0.2,2.5)</span>
    <span class="comment">// 水平速度s.vX = vRndX+rnd(storm.vMaxX*0.12,0.1) –-from setVelocities（）</span>
    <span class="comment">// s.vX = ±[0.2,2.5) + [0.1,2.5*0.12);</span>
    <span class="comment">// 水平速度≠水平风速？为什么要修正[0.1,2.5*0.12)，0.12是怎么来的？</span>
    <span class="comment">// 风偏速windOffset默认为1，并根据鼠标移动的位置计算。处于屏幕中间为0，最左侧为-2，最右侧为2；windOffset∈[-2,2]</span>
    <span class="keyword">var</span> vX = s.vX*windOffset, yDiff;
    <span class="comment">// 单位时间运动的终点值=初始值+水平速度</span>
    s.x += vX;
    <span class="comment">// 同理s.vX = [0.2,2.5) + [0.1,2.5*0.12);</span>
    <span class="comment">// 之前忽略了一点，雪花和雪花是不一样的。尤其是轻重不同，那下落速度必定不同。</span>
    <span class="comment">// this.vAmpTypes = [1,1.2,1.4,1.6,1.8];</span>
    <span class="comment">// this.type ∈[0,5)的随机整数</span>
    <span class="comment">// this.vAmp = this.vAmpTypes[this.type];</span>
    s.y += (s.vY*s.vAmp);
    <span class="comment">// 边际检测</span>
    <span class="comment">// 右侧出屏幕，设置到左边,左侧出屏幕，设置到右边</span>
    <span class="keyword">if</span> (s.x &gt;= screenX || screenX-s.x &lt; storm.flakeWidth) { <span class="comment">// X-axis scroll check</span>
    s.x = <span class="number">0</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (vX &lt; <span class="number">0</span> &amp;&amp; s.x-storm.flakeLeftOffset &lt; -storm.flakeWidth) {
    s.x = screenX-storm.flakeWidth-<span class="number">1</span>; <span class="comment">// flakeWidth;</span>
    }
    <span class="comment">// 设置到页面中</span>
    s.refresh();
    <span class="comment">// yDiff 当前雪花位置距离屏幕底部的高度</span>
    <span class="comment">// 以下实现雪花是否成堆、融化的效果，不再赘述</span>
    yDiff = screenY+scrollY-s.y+storm.flakeHeight;
    <span class="keyword">if</span> (yDiff&lt;storm.flakeHeight) {
        s.active = <span class="number">0</span>;
        <span class="keyword">if</span> (storm.snowStick) {
          s.stick();
        } <span class="keyword">else</span> {
          s.recycle();
        }
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (storm.useMeltEffect &amp;&amp; s.active &amp;&amp; s.type &lt; <span class="number">3</span> &amp;&amp; !s.melting &amp;&amp; <span class="built_in">Math</span>.random()&gt;<span class="number">0.998</span>) {
          <span class="comment">// ~1/1000 chance of melting mid-air, with each frame</span>
          s.melting = <span class="literal">true</span>;
          s.melt();
          <span class="comment">// only incrementally melt one frame</span>
          <span class="comment">// s.melting = false;</span>
        }
        <span class="keyword">if</span> (storm.useTwinkleEffect) {
          <span class="keyword">if</span> (s.twinkleFrame &lt; <span class="number">0</span>) {
            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.97</span>) {
              s.twinkleFrame = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">8</span>, <span class="number">10</span>);
            }
          } <span class="keyword">else</span> {
            s.twinkleFrame--;
            <span class="keyword">if</span> (!opacitySupported) {
              s.o.style.visibility = (s.twinkleFrame &amp;&amp; s.twinkleFrame % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'hidden'</span> : <span class="string">'visible'</span>);
            } <span class="keyword">else</span> {
              s.o.style.opacity = (s.twinkleFrame &amp;&amp; s.twinkleFrame % <span class="number">2</span> === <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);
            }
          }
        }
    }
};
</code></pre><h3 id="3、执行定时器ergrg">3、执行定时器ergrg</h3>
<p>那么，遍历所有的雪花，让她们飘去吧。要么setInterval、要么递归调用setTimeout。</p>
<pre><code><span class="transposed_variable">this.</span>snow = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    var active = <span class="number">0</span>, flake = null, <span class="built_in">i</span>, <span class="built_in">j</span>;
    <span class="keyword">for</span> (<span class="built_in">i</span>=<span class="number">0</span>, <span class="built_in">j</span>=<span class="transposed_variable">storm.</span><span class="transposed_variable">flakes.</span><span class="built_in">length</span>; <span class="built_in">i</span>&lt;<span class="built_in">j</span>; <span class="built_in">i</span>++) <span class="cell">{
      if (storm.flakes[i].active === <span class="number">1</span>) {
        storm.flakes[i].move();
        active++;
      }</span>
      <span class="keyword">if</span> (<span class="transposed_variable">storm.</span>flakes<span class="matrix">[i].</span>melting) <span class="cell">{
        storm.flakes[i].melt();
      }</span>
    }
    ……
    <span class="keyword">if</span> (<span class="transposed_variable">storm.</span>timer) <span class="cell">{
      features.getAnimationFrame(storm.snow);
    }</span>                
};
</code></pre><p>这里引入了一个新的专业名词“requestAnimationFrame”。</p>
<p>我们知道，setInterval、setTimeout在实现动画的流畅性上总是不理想。动画比较棘手的问题是延迟应该多少，一方面要必须短，从而使动画流畅地进行，另一方面还要足够长，使得浏览器可以完成渲染。大多数浏览器的刷新频率为60Hz，即每秒60次刷新，那流畅动画的最佳间隔是1000ms/60约为17ms。其次的问题是无法精确，第二个参数指定的延迟表示代码何时会添加到浏览器的UI线程队列中。如果UI线程处于繁忙状态，那代码不会被马上执行。再次，即使看不到网页，或是处于背景选项卡中的页面，动画都会频繁出现，导致过度绘制。</p>
<p>实际上，CSS transitions 和 animations的动画都非常平滑，优势在于浏览器知道哪些动画将会发生。而javascript动画，浏览器不知道动画正在发生。所以一个独特的方案就是创建一个requestAnimationFrame（）方法来告诉浏览器哪些javascript代码正在执行，而计时由系统处理，与浏览器的绘制时间间隔保持一致。此方法接受一个参数，是一个动画函数，并需要在函数最后再次调用requestAnimationFrame（）方法。</p>
<p>requestAnimationFrame（）API是W3C起草的一个新议案，目前chrome10+、firefox 4+、IE10+已支持。上述代码中getAnimationFrame方法针对不同浏览器对requestAnimationFrame进行了封装，的实现如下：</p>
<pre><code><span class="reserved">function</span> timeoutShim(callback) {
    <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span>/(storm.animationInterval || <span class="number">20</span>));
}

<span class="reserved">var</span> _animationFrame = (<span class="built_in">window</span>.requestAnimationFrame ||
    <span class="built_in">window</span>.webkitRequestAnimationFrame ||
    <span class="built_in">window</span>.mozRequestAnimationFrame ||
    <span class="built_in">window</span>.oRequestAnimationFrame ||
    <span class="built_in">window</span>.msRequestAnimationFrame ||
    timeoutShim);

<span class="regexp">//</span> apply to <span class="built_in">window</span>, avoid <span class="string">"illegal invocation"</span> errors <span class="keyword">in</span> Chrome
getAnimationFrame = _animationFrame ? <span class="reserved">function</span>() {
    <span class="keyword">return</span> _animationFrame.apply(<span class="built_in">window</span>, arguments);
} : <span class="literal">null</span>;
</code></pre><p>最后，总结一下代码结构如下：<br><img src="/img/snowflake.png" alt="雅虎科技"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我查找MVC、MVP、MVVM这些设计模式相关资料时，发现了这个背景效果——飘雪——做得还不错的网站，<a href="http://nirajrules.wordpress.com/2009/07/18/mvc-vs-mvp-vs-mvvm/" target="_bla]]>
    </summary>
    
      <category term="js动画 css3 requestAnimationFrame 雪花动画" scheme="http://yoursite.com/tags/js%E5%8A%A8%E7%94%BB-css3-requestAnimationFrame-%E9%9B%AA%E8%8A%B1%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
